
SAM3X8E_OfficialDevelopment.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002044  00080000  00080000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000430  20000000  00082044  00020000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00001800  20000430  00082474  00020430  2**2
                  ALLOC
  3 .stack        00000400  20001c30  00083c74  00020430  2**0
                  ALLOC
  4 .heap         00000200  20002030  00084074  00020430  2**0
                  ALLOC
  5 .ARM.attributes 00000029  00000000  00000000  00020430  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  00020459  2**0
                  CONTENTS, READONLY
  7 .debug_info   0001a344  00000000  00000000  000204b2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00003aa8  00000000  00000000  0003a7f6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0000ae1b  00000000  00000000  0003e29e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 000008a8  00000000  00000000  000490b9  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00001bb8  00000000  00000000  00049961  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  0000f9fd  00000000  00000000  0004b519  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00005c1e  00000000  00000000  0005af16  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00052b94  00000000  00000000  00060b34  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00001950  00000000  00000000  000b36c8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00080000 <_sfixed>:
   80000:	20002030 	.word	0x20002030
   80004:	00080155 	.word	0x00080155
   80008:	00080151 	.word	0x00080151
   8000c:	00080151 	.word	0x00080151
   80010:	00080151 	.word	0x00080151
   80014:	00080151 	.word	0x00080151
   80018:	00080151 	.word	0x00080151
	...
   8002c:	00080151 	.word	0x00080151
   80030:	00080151 	.word	0x00080151
   80034:	00000000 	.word	0x00000000
   80038:	00080151 	.word	0x00080151
   8003c:	00080151 	.word	0x00080151
   80040:	00080151 	.word	0x00080151
   80044:	00080151 	.word	0x00080151
   80048:	00080151 	.word	0x00080151
   8004c:	00080151 	.word	0x00080151
   80050:	00080151 	.word	0x00080151
   80054:	00080151 	.word	0x00080151
   80058:	00080151 	.word	0x00080151
   8005c:	00080151 	.word	0x00080151
   80060:	00080295 	.word	0x00080295
   80064:	00080151 	.word	0x00080151
   80068:	00000000 	.word	0x00000000
   8006c:	00080151 	.word	0x00080151
   80070:	00080151 	.word	0x00080151
   80074:	00080151 	.word	0x00080151
   80078:	00080151 	.word	0x00080151
	...
   80084:	000802a5 	.word	0x000802a5
   80088:	000802b5 	.word	0x000802b5
   8008c:	00080151 	.word	0x00080151
   80090:	000802c5 	.word	0x000802c5
   80094:	00080151 	.word	0x00080151
   80098:	000802d5 	.word	0x000802d5
   8009c:	000802e5 	.word	0x000802e5
   800a0:	000802f5 	.word	0x000802f5
   800a4:	00000000 	.word	0x00000000
   800a8:	00080151 	.word	0x00080151
   800ac:	00080305 	.word	0x00080305
   800b0:	00080151 	.word	0x00080151
   800b4:	00080151 	.word	0x00080151
   800b8:	00080151 	.word	0x00080151
   800bc:	00080151 	.word	0x00080151
   800c0:	00080151 	.word	0x00080151
   800c4:	00080151 	.word	0x00080151
   800c8:	00080151 	.word	0x00080151
   800cc:	00080151 	.word	0x00080151
   800d0:	00080151 	.word	0x00080151
   800d4:	00080151 	.word	0x00080151
   800d8:	00080151 	.word	0x00080151
   800dc:	00080151 	.word	0x00080151
   800e0:	00080151 	.word	0x00080151
   800e4:	00080151 	.word	0x00080151
   800e8:	00080151 	.word	0x00080151
   800ec:	00080151 	.word	0x00080151
   800f0:	00080151 	.word	0x00080151

000800f4 <__do_global_dtors_aux>:
   800f4:	b510      	push	{r4, lr}
   800f6:	4c05      	ldr	r4, [pc, #20]	; (8010c <__do_global_dtors_aux+0x18>)
   800f8:	7823      	ldrb	r3, [r4, #0]
   800fa:	b933      	cbnz	r3, 8010a <__do_global_dtors_aux+0x16>
   800fc:	4b04      	ldr	r3, [pc, #16]	; (80110 <__do_global_dtors_aux+0x1c>)
   800fe:	b113      	cbz	r3, 80106 <__do_global_dtors_aux+0x12>
   80100:	4804      	ldr	r0, [pc, #16]	; (80114 <__do_global_dtors_aux+0x20>)
   80102:	f3af 8000 	nop.w
   80106:	2301      	movs	r3, #1
   80108:	7023      	strb	r3, [r4, #0]
   8010a:	bd10      	pop	{r4, pc}
   8010c:	20000430 	.word	0x20000430
   80110:	00000000 	.word	0x00000000
   80114:	00082044 	.word	0x00082044

00080118 <frame_dummy>:
   80118:	4b08      	ldr	r3, [pc, #32]	; (8013c <frame_dummy+0x24>)
   8011a:	b510      	push	{r4, lr}
   8011c:	b11b      	cbz	r3, 80126 <frame_dummy+0xe>
   8011e:	4908      	ldr	r1, [pc, #32]	; (80140 <frame_dummy+0x28>)
   80120:	4808      	ldr	r0, [pc, #32]	; (80144 <frame_dummy+0x2c>)
   80122:	f3af 8000 	nop.w
   80126:	4808      	ldr	r0, [pc, #32]	; (80148 <frame_dummy+0x30>)
   80128:	6803      	ldr	r3, [r0, #0]
   8012a:	b903      	cbnz	r3, 8012e <frame_dummy+0x16>
   8012c:	bd10      	pop	{r4, pc}
   8012e:	4b07      	ldr	r3, [pc, #28]	; (8014c <frame_dummy+0x34>)
   80130:	2b00      	cmp	r3, #0
   80132:	d0fb      	beq.n	8012c <frame_dummy+0x14>
   80134:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   80138:	4718      	bx	r3
   8013a:	bf00      	nop
   8013c:	00000000 	.word	0x00000000
   80140:	20000434 	.word	0x20000434
   80144:	00082044 	.word	0x00082044
   80148:	00082044 	.word	0x00082044
   8014c:	00000000 	.word	0x00000000

00080150 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
   80150:	e7fe      	b.n	80150 <Dummy_Handler>
   80152:	bf00      	nop

00080154 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
   80154:	b508      	push	{r3, lr}

        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
   80156:	4b1a      	ldr	r3, [pc, #104]	; (801c0 <Reset_Handler+0x6c>)
   80158:	4a1a      	ldr	r2, [pc, #104]	; (801c4 <Reset_Handler+0x70>)
   8015a:	429a      	cmp	r2, r3
   8015c:	d003      	beq.n	80166 <Reset_Handler+0x12>
                for (; pDest < &_erelocate;) {
   8015e:	4b1a      	ldr	r3, [pc, #104]	; (801c8 <Reset_Handler+0x74>)
   80160:	4a17      	ldr	r2, [pc, #92]	; (801c0 <Reset_Handler+0x6c>)
   80162:	429a      	cmp	r2, r3
   80164:	d304      	bcc.n	80170 <Reset_Handler+0x1c>
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
   80166:	4b19      	ldr	r3, [pc, #100]	; (801cc <Reset_Handler+0x78>)
   80168:	4a19      	ldr	r2, [pc, #100]	; (801d0 <Reset_Handler+0x7c>)
   8016a:	429a      	cmp	r2, r3
   8016c:	d30f      	bcc.n	8018e <Reset_Handler+0x3a>
   8016e:	e01a      	b.n	801a6 <Reset_Handler+0x52>
   80170:	4913      	ldr	r1, [pc, #76]	; (801c0 <Reset_Handler+0x6c>)
   80172:	4b18      	ldr	r3, [pc, #96]	; (801d4 <Reset_Handler+0x80>)
   80174:	1a5b      	subs	r3, r3, r1
   80176:	f023 0303 	bic.w	r3, r3, #3
   8017a:	3304      	adds	r3, #4
   8017c:	4a11      	ldr	r2, [pc, #68]	; (801c4 <Reset_Handler+0x70>)
   8017e:	4413      	add	r3, r2
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
                        *pDest++ = *pSrc++;
   80180:	f852 0b04 	ldr.w	r0, [r2], #4
   80184:	f841 0b04 	str.w	r0, [r1], #4
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
   80188:	429a      	cmp	r2, r3
   8018a:	d1f9      	bne.n	80180 <Reset_Handler+0x2c>
   8018c:	e7eb      	b.n	80166 <Reset_Handler+0x12>
   8018e:	4b12      	ldr	r3, [pc, #72]	; (801d8 <Reset_Handler+0x84>)
   80190:	4a12      	ldr	r2, [pc, #72]	; (801dc <Reset_Handler+0x88>)
   80192:	1ad2      	subs	r2, r2, r3
   80194:	f022 0203 	bic.w	r2, r2, #3
   80198:	441a      	add	r2, r3
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
   8019a:	3b04      	subs	r3, #4
                *pDest++ = 0;
   8019c:	2100      	movs	r1, #0
   8019e:	f843 1b04 	str.w	r1, [r3], #4
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
   801a2:	4293      	cmp	r3, r2
   801a4:	d1fb      	bne.n	8019e <Reset_Handler+0x4a>
                *pDest++ = 0;
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
   801a6:	4b0e      	ldr	r3, [pc, #56]	; (801e0 <Reset_Handler+0x8c>)
   801a8:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
   801ac:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
   801b0:	4a0c      	ldr	r2, [pc, #48]	; (801e4 <Reset_Handler+0x90>)
   801b2:	6093      	str	r3, [r2, #8]

        /* Initialize the C library */
        __libc_init_array();
   801b4:	4b0c      	ldr	r3, [pc, #48]	; (801e8 <Reset_Handler+0x94>)
   801b6:	4798      	blx	r3

        /* Branch to main function */
        main();
   801b8:	4b0c      	ldr	r3, [pc, #48]	; (801ec <Reset_Handler+0x98>)
   801ba:	4798      	blx	r3
   801bc:	e7fe      	b.n	801bc <Reset_Handler+0x68>
   801be:	bf00      	nop
   801c0:	20000000 	.word	0x20000000
   801c4:	00082044 	.word	0x00082044
   801c8:	20000430 	.word	0x20000430
   801cc:	20001c30 	.word	0x20001c30
   801d0:	20000430 	.word	0x20000430
   801d4:	2000042f 	.word	0x2000042f
   801d8:	20000434 	.word	0x20000434
   801dc:	20001c33 	.word	0x20001c33
   801e0:	00080000 	.word	0x00080000
   801e4:	e000ed00 	.word	0xe000ed00
   801e8:	0008140d 	.word	0x0008140d
   801ec:	000803f5 	.word	0x000803f5

000801f0 <SystemInit>:
 * Initialize the System and update the SystemFrequency variable.
 */
void SystemInit( void )
{
  /* Set FWS according to SYS_BOARD_MCKR configuration */
  EFC0->EEFC_FMR = EEFC_FMR_FWS(4);
   801f0:	f44f 6380 	mov.w	r3, #1024	; 0x400
   801f4:	4a20      	ldr	r2, [pc, #128]	; (80278 <SystemInit+0x88>)
   801f6:	6013      	str	r3, [r2, #0]
  EFC1->EEFC_FMR = EEFC_FMR_FWS(4);
   801f8:	f502 7200 	add.w	r2, r2, #512	; 0x200
   801fc:	6013      	str	r3, [r2, #0]

  /* Initialize main oscillator */
  if ( !(PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) )
   801fe:	4b1f      	ldr	r3, [pc, #124]	; (8027c <SystemInit+0x8c>)
   80200:	6a1b      	ldr	r3, [r3, #32]
   80202:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
   80206:	d107      	bne.n	80218 <SystemInit+0x28>
  {
    PMC->CKGR_MOR = CKGR_MOR_KEY_PASSWD | SYS_BOARD_OSCOUNT | CKGR_MOR_MOSCRCEN | CKGR_MOR_MOSCXTEN;
   80208:	4a1d      	ldr	r2, [pc, #116]	; (80280 <SystemInit+0x90>)
   8020a:	4b1c      	ldr	r3, [pc, #112]	; (8027c <SystemInit+0x8c>)
   8020c:	621a      	str	r2, [r3, #32]
    while ( !(PMC->PMC_SR & PMC_SR_MOSCXTS) )
   8020e:	461a      	mov	r2, r3
   80210:	6e93      	ldr	r3, [r2, #104]	; 0x68
   80212:	f013 0f01 	tst.w	r3, #1
   80216:	d0fb      	beq.n	80210 <SystemInit+0x20>
    {
    }
  }

  /* Switch to 3-20MHz Xtal oscillator */
  PMC->CKGR_MOR = CKGR_MOR_KEY_PASSWD | SYS_BOARD_OSCOUNT | CKGR_MOR_MOSCRCEN | CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCSEL;
   80218:	4a1a      	ldr	r2, [pc, #104]	; (80284 <SystemInit+0x94>)
   8021a:	4b18      	ldr	r3, [pc, #96]	; (8027c <SystemInit+0x8c>)
   8021c:	621a      	str	r2, [r3, #32]

  while ( !(PMC->PMC_SR & PMC_SR_MOSCSELS) )
   8021e:	461a      	mov	r2, r3
   80220:	6e93      	ldr	r3, [r2, #104]	; 0x68
   80222:	f413 3f80 	tst.w	r3, #65536	; 0x10000
   80226:	d0fb      	beq.n	80220 <SystemInit+0x30>
  {
  }
 	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~(uint32_t)PMC_MCKR_CSS_Msk) | PMC_MCKR_CSS_MAIN_CLK;
   80228:	4a14      	ldr	r2, [pc, #80]	; (8027c <SystemInit+0x8c>)
   8022a:	6b13      	ldr	r3, [r2, #48]	; 0x30
   8022c:	f023 0303 	bic.w	r3, r3, #3
   80230:	f043 0301 	orr.w	r3, r3, #1
   80234:	6313      	str	r3, [r2, #48]	; 0x30
  while (!(PMC->PMC_SR & PMC_SR_MCKRDY))
   80236:	6e93      	ldr	r3, [r2, #104]	; 0x68
   80238:	f013 0f08 	tst.w	r3, #8
   8023c:	d0fb      	beq.n	80236 <SystemInit+0x46>
  {
  }

  /* Initialize PLLA */
  PMC->CKGR_PLLAR = SYS_BOARD_PLLAR;
   8023e:	4a12      	ldr	r2, [pc, #72]	; (80288 <SystemInit+0x98>)
   80240:	4b0e      	ldr	r3, [pc, #56]	; (8027c <SystemInit+0x8c>)
   80242:	629a      	str	r2, [r3, #40]	; 0x28
  while ( !(PMC->PMC_SR & PMC_SR_LOCKA) )
   80244:	461a      	mov	r2, r3
   80246:	6e93      	ldr	r3, [r2, #104]	; 0x68
   80248:	f013 0f02 	tst.w	r3, #2
   8024c:	d0fb      	beq.n	80246 <SystemInit+0x56>
  {
  }

  /* Switch to main clock */
  PMC->PMC_MCKR = (SYS_BOARD_MCKR & ~PMC_MCKR_CSS_Msk) | PMC_MCKR_CSS_MAIN_CLK;
   8024e:	2211      	movs	r2, #17
   80250:	4b0a      	ldr	r3, [pc, #40]	; (8027c <SystemInit+0x8c>)
   80252:	631a      	str	r2, [r3, #48]	; 0x30
  while ( !(PMC->PMC_SR & PMC_SR_MCKRDY) )
   80254:	461a      	mov	r2, r3
   80256:	6e93      	ldr	r3, [r2, #104]	; 0x68
   80258:	f013 0f08 	tst.w	r3, #8
   8025c:	d0fb      	beq.n	80256 <SystemInit+0x66>
  {
  }

  /* Switch to PLLA */
  PMC->PMC_MCKR = SYS_BOARD_MCKR;
   8025e:	2212      	movs	r2, #18
   80260:	4b06      	ldr	r3, [pc, #24]	; (8027c <SystemInit+0x8c>)
   80262:	631a      	str	r2, [r3, #48]	; 0x30
  while ( !(PMC->PMC_SR & PMC_SR_MCKRDY) )
   80264:	461a      	mov	r2, r3
   80266:	6e93      	ldr	r3, [r2, #104]	; 0x68
   80268:	f013 0f08 	tst.w	r3, #8
   8026c:	d0fb      	beq.n	80266 <SystemInit+0x76>
  {
  }

  SystemCoreClock = CHIP_FREQ_CPU_MAX;
   8026e:	4a07      	ldr	r2, [pc, #28]	; (8028c <SystemInit+0x9c>)
   80270:	4b07      	ldr	r3, [pc, #28]	; (80290 <SystemInit+0xa0>)
   80272:	601a      	str	r2, [r3, #0]
   80274:	4770      	bx	lr
   80276:	bf00      	nop
   80278:	400e0a00 	.word	0x400e0a00
   8027c:	400e0600 	.word	0x400e0600
   80280:	00370809 	.word	0x00370809
   80284:	01370809 	.word	0x01370809
   80288:	200d3f01 	.word	0x200d3f01
   8028c:	0501bd00 	.word	0x0501bd00
   80290:	20000000 	.word	0x20000000

00080294 <UART_Handler>:
UARTClass Serial;

//Interrupt Handler
void UART_Handler(void)
{
	Serial.IrqHandler();
   80294:	4801      	ldr	r0, [pc, #4]	; (8029c <UART_Handler+0x8>)
   80296:	4b02      	ldr	r3, [pc, #8]	; (802a0 <UART_Handler+0xc>)
   80298:	4718      	bx	r3
   8029a:	bf00      	nop
   8029c:	20000814 	.word	0x20000814
   802a0:	000811d1 	.word	0x000811d1

000802a4 <USART0_Handler>:
USARTClass Serial2(2);
USARTClass Serial3(3);

//Interrupt Handlers
void USART0_Handler(void){
	Serial1.IrqHandler();
   802a4:	4801      	ldr	r0, [pc, #4]	; (802ac <USART0_Handler+0x8>)
   802a6:	4b02      	ldr	r3, [pc, #8]	; (802b0 <USART0_Handler+0xc>)
   802a8:	4718      	bx	r3
   802aa:	bf00      	nop
   802ac:	200008d0 	.word	0x200008d0
   802b0:	000813a1 	.word	0x000813a1

000802b4 <USART1_Handler>:
}


void USART1_Handler(void){
	Serial2.IrqHandler();
   802b4:	4801      	ldr	r0, [pc, #4]	; (802bc <USART1_Handler+0x8>)
   802b6:	4b02      	ldr	r3, [pc, #8]	; (802c0 <USART1_Handler+0xc>)
   802b8:	4718      	bx	r3
   802ba:	bf00      	nop
   802bc:	20000ddc 	.word	0x20000ddc
   802c0:	000813a1 	.word	0x000813a1

000802c4 <USART3_Handler>:
}


void USART3_Handler(void){
	Serial3.IrqHandler();
   802c4:	4801      	ldr	r0, [pc, #4]	; (802cc <USART3_Handler+0x8>)
   802c6:	4b02      	ldr	r3, [pc, #8]	; (802d0 <USART3_Handler+0xc>)
   802c8:	4718      	bx	r3
   802ca:	bf00      	nop
   802cc:	200012e8 	.word	0x200012e8
   802d0:	000813a1 	.word	0x000813a1

000802d4 <TWI0_Handler>:
TwoWireClass Wire(TWI1);	//20, 21
TwoWireClass Wire1(TWI0);	//Unlabeled

/** Interrupt Handlers*/
void TWI0_Handler(){ //Wire1
	Wire1.IRQHandler();
   802d4:	4801      	ldr	r0, [pc, #4]	; (802dc <TWI0_Handler+0x8>)
   802d6:	4b02      	ldr	r3, [pc, #8]	; (802e0 <TWI0_Handler+0xc>)
   802d8:	4718      	bx	r3
   802da:	bf00      	nop
   802dc:	200006ac 	.word	0x200006ac
   802e0:	00081071 	.word	0x00081071

000802e4 <TWI1_Handler>:
};

void TWI1_Handler(){ //Wire
	Wire.IRQHandler();
   802e4:	4801      	ldr	r0, [pc, #4]	; (802ec <TWI1_Handler+0x8>)
   802e6:	4b02      	ldr	r3, [pc, #8]	; (802f0 <TWI1_Handler+0xc>)
   802e8:	4718      	bx	r3
   802ea:	bf00      	nop
   802ec:	200017f4 	.word	0x200017f4
   802f0:	00081071 	.word	0x00081071

000802f4 <SPI0_Handler>:
SPI Objects
******************/
SPIClass SPI;

void SPI0_Handler(){
	SPI.IRQHandler();
   802f4:	4801      	ldr	r0, [pc, #4]	; (802fc <SPI0_Handler+0x8>)
   802f6:	4b02      	ldr	r3, [pc, #8]	; (80300 <SPI0_Handler+0xc>)
   802f8:	4718      	bx	r3
   802fa:	bf00      	nop
   802fc:	20001938 	.word	0x20001938
   80300:	0008096d 	.word	0x0008096d

00080304 <TC0_Handler>:
Timer Objects
******************/
SystemTickClass milliSysTick(0, 1000);

void TC0_Handler(){
	milliSysTick.IRQHandler();
   80304:	4801      	ldr	r0, [pc, #4]	; (8030c <TC0_Handler+0x8>)
   80306:	4b02      	ldr	r3, [pc, #8]	; (80310 <TC0_Handler+0xc>)
   80308:	4718      	bx	r3
   8030a:	bf00      	nop
   8030c:	200007f0 	.word	0x200007f0
   80310:	00080c51 	.word	0x00080c51

00080314 <_GLOBAL__sub_I_taskList>:
}
   80314:	b510      	push	{r4, lr}
/************************************************************************/

/*****************
Task Scheduler
******************/
Scheduler taskList = Scheduler();
   80316:	4b11      	ldr	r3, [pc, #68]	; (8035c <_GLOBAL__sub_I_taskList+0x48>)
   80318:	4811      	ldr	r0, [pc, #68]	; (80360 <_GLOBAL__sub_I_taskList+0x4c>)
   8031a:	4798      	blx	r3

/*****************
UART Objects
******************/
UARTClass Serial;
   8031c:	4b11      	ldr	r3, [pc, #68]	; (80364 <_GLOBAL__sub_I_taskList+0x50>)
   8031e:	4812      	ldr	r0, [pc, #72]	; (80368 <_GLOBAL__sub_I_taskList+0x54>)
   80320:	4798      	blx	r3

/*****************
USART Objects
******************/

USARTClass Serial1(1);
   80322:	4c12      	ldr	r4, [pc, #72]	; (8036c <_GLOBAL__sub_I_taskList+0x58>)
   80324:	2101      	movs	r1, #1
   80326:	4812      	ldr	r0, [pc, #72]	; (80370 <_GLOBAL__sub_I_taskList+0x5c>)
   80328:	47a0      	blx	r4
USARTClass Serial2(2);
   8032a:	2102      	movs	r1, #2
   8032c:	4811      	ldr	r0, [pc, #68]	; (80374 <_GLOBAL__sub_I_taskList+0x60>)
   8032e:	47a0      	blx	r4
USARTClass Serial3(3);
   80330:	2103      	movs	r1, #3
   80332:	4811      	ldr	r0, [pc, #68]	; (80378 <_GLOBAL__sub_I_taskList+0x64>)
   80334:	47a0      	blx	r4
/*****************
I2C Objects
******************/

/** Class objects*/
TwoWireClass Wire(TWI1);	//20, 21
   80336:	4c11      	ldr	r4, [pc, #68]	; (8037c <_GLOBAL__sub_I_taskList+0x68>)
   80338:	4911      	ldr	r1, [pc, #68]	; (80380 <_GLOBAL__sub_I_taskList+0x6c>)
   8033a:	4812      	ldr	r0, [pc, #72]	; (80384 <_GLOBAL__sub_I_taskList+0x70>)
   8033c:	47a0      	blx	r4
TwoWireClass Wire1(TWI0);	//Unlabeled
   8033e:	4912      	ldr	r1, [pc, #72]	; (80388 <_GLOBAL__sub_I_taskList+0x74>)
   80340:	4812      	ldr	r0, [pc, #72]	; (8038c <_GLOBAL__sub_I_taskList+0x78>)
   80342:	47a0      	blx	r4
}

/*****************
SPI Objects
******************/
SPIClass SPI;
   80344:	4b12      	ldr	r3, [pc, #72]	; (80390 <_GLOBAL__sub_I_taskList+0x7c>)
   80346:	4813      	ldr	r0, [pc, #76]	; (80394 <_GLOBAL__sub_I_taskList+0x80>)
   80348:	4798      	blx	r3
******************/
SystemTickClass milliSysTick(0, 1000);

void TC0_Handler(){
	milliSysTick.IRQHandler();
}
   8034a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	SPI.IRQHandler();
}
/*****************
Timer Objects
******************/
SystemTickClass milliSysTick(0, 1000);
   8034e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   80352:	2100      	movs	r1, #0
   80354:	4810      	ldr	r0, [pc, #64]	; (80398 <_GLOBAL__sub_I_taskList+0x84>)
   80356:	4b11      	ldr	r3, [pc, #68]	; (8039c <_GLOBAL__sub_I_taskList+0x88>)
   80358:	4718      	bx	r3
   8035a:	bf00      	nop
   8035c:	0008078d 	.word	0x0008078d
   80360:	2000044c 	.word	0x2000044c
   80364:	000811a1 	.word	0x000811a1
   80368:	20000814 	.word	0x20000814
   8036c:	00081231 	.word	0x00081231
   80370:	200008d0 	.word	0x200008d0
   80374:	20000ddc 	.word	0x20000ddc
   80378:	200012e8 	.word	0x200012e8
   8037c:	00080cd9 	.word	0x00080cd9
   80380:	40090000 	.word	0x40090000
   80384:	200017f4 	.word	0x200017f4
   80388:	4008c000 	.word	0x4008c000
   8038c:	200006ac 	.word	0x200006ac
   80390:	00080909 	.word	0x00080909
   80394:	20001938 	.word	0x20001938
   80398:	200007f0 	.word	0x200007f0
   8039c:	00080a99 	.word	0x00080a99

000803a0 <_Z8testFuncv>:

LSM9DS0 LSM = LSM9DS0(&SPI, CONFIG, XM_CH, XM_CS, GYRO_CH, GYRO_CS);
VCNL4010 PROX = VCNL4010(&Wire);


void testFunc(){
   803a0:	b510      	push	{r4, lr}
	//Write 1
	Wire.beginTransmission(0x13);
   803a2:	4c0c      	ldr	r4, [pc, #48]	; (803d4 <_Z8testFuncv+0x34>)
   803a4:	2113      	movs	r1, #19
   803a6:	4620      	mov	r0, r4
   803a8:	4b0b      	ldr	r3, [pc, #44]	; (803d8 <_Z8testFuncv+0x38>)
   803aa:	4798      	blx	r3
	Wire.write(0x87);
   803ac:	2187      	movs	r1, #135	; 0x87
   803ae:	4620      	mov	r0, r4
   803b0:	4b0a      	ldr	r3, [pc, #40]	; (803dc <_Z8testFuncv+0x3c>)
   803b2:	4798      	blx	r3
	Wire.endTransmission();
   803b4:	4620      	mov	r0, r4
   803b6:	4b0a      	ldr	r3, [pc, #40]	; (803e0 <_Z8testFuncv+0x40>)
   803b8:	4798      	blx	r3

	Wire.requestFrom(0x13, 1);
   803ba:	4620      	mov	r0, r4
   803bc:	2201      	movs	r2, #1
   803be:	2113      	movs	r1, #19
   803c0:	4b08      	ldr	r3, [pc, #32]	; (803e4 <_Z8testFuncv+0x44>)
   803c2:	4798      	blx	r3
// 
// 	Wire.requestFrom(0x13, 1);
	
	//PROX.readProximity();
	taskList.schedule(testFunc, 1000);
}
   803c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
// 	Wire.endTransmission();
// 
// 	Wire.requestFrom(0x13, 1);
	
	//PROX.readProximity();
	taskList.schedule(testFunc, 1000);
   803c8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   803cc:	4906      	ldr	r1, [pc, #24]	; (803e8 <_Z8testFuncv+0x48>)
   803ce:	4807      	ldr	r0, [pc, #28]	; (803ec <_Z8testFuncv+0x4c>)
   803d0:	4b07      	ldr	r3, [pc, #28]	; (803f0 <_Z8testFuncv+0x50>)
   803d2:	4718      	bx	r3
   803d4:	200017f4 	.word	0x200017f4
   803d8:	00080edd 	.word	0x00080edd
   803dc:	00080f05 	.word	0x00080f05
   803e0:	00080f1d 	.word	0x00080f1d
   803e4:	00080fe1 	.word	0x00080fe1
   803e8:	000803a1 	.word	0x000803a1
   803ec:	2000044c 	.word	0x2000044c
   803f0:	000808d9 	.word	0x000808d9

000803f4 <main>:
}


int main(void)
{
   803f4:	b508      	push	{r3, lr}
    /* Initialize the SAM system */
    SystemInit();
   803f6:	4b13      	ldr	r3, [pc, #76]	; (80444 <main+0x50>)
   803f8:	4798      	blx	r3
	
	//Setup the debug pins
	pinMode(debugPin1, OUTPUT);
   803fa:	4c13      	ldr	r4, [pc, #76]	; (80448 <main+0x54>)
   803fc:	2100      	movs	r1, #0
   803fe:	2017      	movs	r0, #23
   80400:	47a0      	blx	r4
	pinMode(debugPin2, OUTPUT);
   80402:	2100      	movs	r1, #0
   80404:	2019      	movs	r0, #25
   80406:	47a0      	blx	r4
	digitalWrite(debugPin1, HIGH);
   80408:	4c10      	ldr	r4, [pc, #64]	; (8044c <main+0x58>)
   8040a:	2101      	movs	r1, #1
   8040c:	2017      	movs	r0, #23
   8040e:	47a0      	blx	r4
	digitalWrite(debugPin2, HIGH);
   80410:	2101      	movs	r1, #1
   80412:	2019      	movs	r0, #25
   80414:	47a0      	blx	r4

	
	Serial1.begin();
   80416:	480e      	ldr	r0, [pc, #56]	; (80450 <main+0x5c>)
   80418:	4b0e      	ldr	r3, [pc, #56]	; (80454 <main+0x60>)
   8041a:	4798      	blx	r3
	Wire.begin();
   8041c:	4b0e      	ldr	r3, [pc, #56]	; (80458 <main+0x64>)
   8041e:	480f      	ldr	r0, [pc, #60]	; (8045c <main+0x68>)
   80420:	4798      	blx	r3
				GYRO_ODR_190_BW_125, ACCELDATARATE_100HZ, MAGDATARATE_50HZ);
	
	LSM.calibrateLSM9DS0();
	*/
	
	testFunc();
   80422:	4b0f      	ldr	r3, [pc, #60]	; (80460 <main+0x6c>)
   80424:	4798      	blx	r3
	
	
	//Delay a bit to let setup settle.
	delayMilliseconds(500);
   80426:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   8042a:	4b0e      	ldr	r3, [pc, #56]	; (80464 <main+0x70>)
   8042c:	4798      	blx	r3
   8042e:	4d0e      	ldr	r5, [pc, #56]	; (80468 <main+0x74>)
	
    while (1) 
    {
		taskList.update(); //Check if any functions are scheduled to run
   80430:	480e      	ldr	r0, [pc, #56]	; (8046c <main+0x78>)
   80432:	47a8      	blx	r5
		//^^^ Expand this to include the ability to call more than void(*)(void) functions
		
		
		//Sign of life
		digitalWrite(debugPin1, HIGH);
   80434:	2101      	movs	r1, #1
   80436:	2017      	movs	r0, #23
   80438:	47a0      	blx	r4
		digitalWrite(debugPin1, LOW);
   8043a:	2100      	movs	r1, #0
   8043c:	2017      	movs	r0, #23
   8043e:	47a0      	blx	r4
   80440:	e7f6      	b.n	80430 <main+0x3c>
   80442:	bf00      	nop
   80444:	000801f1 	.word	0x000801f1
   80448:	00080501 	.word	0x00080501
   8044c:	00080571 	.word	0x00080571
   80450:	200008d0 	.word	0x200008d0
   80454:	000812a9 	.word	0x000812a9
   80458:	00080e25 	.word	0x00080e25
   8045c:	200017f4 	.word	0x200017f4
   80460:	000803a1 	.word	0x000803a1
   80464:	00080c75 	.word	0x00080c75
   80468:	000807a1 	.word	0x000807a1
   8046c:	2000044c 	.word	0x2000044c

00080470 <_GLOBAL__sub_I_LSM>:
    }
}
   80470:	b510      	push	{r4, lr}
#define XM_CH		0		//Spi channel
#define GYRO_CS		53		//Chip select
#define GYRO_CH		1		//Spi channel
#define CONFIG		(SPI_CSR_BITS_16_BIT | SPI_CSR_NCPHA)

LSM9DS0 LSM = LSM9DS0(&SPI, CONFIG, XM_CH, XM_CS, GYRO_CH, GYRO_CS);
   80472:	2300      	movs	r3, #0
		
		//Sign of life
		digitalWrite(debugPin1, HIGH);
		digitalWrite(debugPin1, LOW);
    }
}
   80474:	b084      	sub	sp, #16
#define XM_CH		0		//Spi channel
#define GYRO_CS		53		//Chip select
#define GYRO_CH		1		//Spi channel
#define CONFIG		(SPI_CSR_BITS_16_BIT | SPI_CSR_NCPHA)

LSM9DS0 LSM = LSM9DS0(&SPI, CONFIG, XM_CH, XM_CS, GYRO_CH, GYRO_CS);
   80476:	2034      	movs	r0, #52	; 0x34
   80478:	2101      	movs	r1, #1
   8047a:	2235      	movs	r2, #53	; 0x35
   8047c:	e88d 000f 	stmia.w	sp, {r0, r1, r2, r3}
   80480:	4c05      	ldr	r4, [pc, #20]	; (80498 <_GLOBAL__sub_I_LSM+0x28>)
   80482:	2282      	movs	r2, #130	; 0x82
   80484:	4905      	ldr	r1, [pc, #20]	; (8049c <_GLOBAL__sub_I_LSM+0x2c>)
   80486:	4806      	ldr	r0, [pc, #24]	; (804a0 <_GLOBAL__sub_I_LSM+0x30>)
   80488:	47a0      	blx	r4
VCNL4010 PROX = VCNL4010(&Wire);
   8048a:	4906      	ldr	r1, [pc, #24]	; (804a4 <_GLOBAL__sub_I_LSM+0x34>)
   8048c:	4806      	ldr	r0, [pc, #24]	; (804a8 <_GLOBAL__sub_I_LSM+0x38>)
   8048e:	4b07      	ldr	r3, [pc, #28]	; (804ac <_GLOBAL__sub_I_LSM+0x3c>)
		
		//Sign of life
		digitalWrite(debugPin1, HIGH);
		digitalWrite(debugPin1, LOW);
    }
}
   80490:	b004      	add	sp, #16
   80492:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
#define GYRO_CS		53		//Chip select
#define GYRO_CH		1		//Spi channel
#define CONFIG		(SPI_CSR_BITS_16_BIT | SPI_CSR_NCPHA)

LSM9DS0 LSM = LSM9DS0(&SPI, CONFIG, XM_CH, XM_CS, GYRO_CH, GYRO_CS);
VCNL4010 PROX = VCNL4010(&Wire);
   80496:	4718      	bx	r3
   80498:	000804b5 	.word	0x000804b5
   8049c:	20001938 	.word	0x20001938
   804a0:	20001b70 	.word	0x20001b70
   804a4:	200017f4 	.word	0x200017f4
   804a8:	20001b68 	.word	0x20001b68
   804ac:	000804b1 	.word	0x000804b1

000804b0 <_ZN8VCNL4010C1EP12TwoWireClass>:

#include "../libraries.h"

VCNL4010::VCNL4010(TwoWireClass *pTwi){
	twi = pTwi;
   804b0:	6041      	str	r1, [r0, #4]
}
   804b2:	4770      	bx	lr

000804b4 <_ZN7LSM9DS0C1EP8SPIClassmmmmml>:
/***************************************************************************
 CONSTRUCTOR
 ***************************************************************************/

/** Hardware SPI Interface **/
LSM9DS0::LSM9DS0(SPIClass* spiInstance, uint32_t spiSettings, uint32_t xmCH, uint32_t xmCS, uint32_t gyroCH, uint32_t gyroCS, int32_t sensorID) {
   804b4:	b4f0      	push	{r4, r5, r6, r7}
   804b6:	9f06      	ldr	r7, [sp, #24]
   804b8:	9e04      	ldr	r6, [sp, #16]
   804ba:	9d05      	ldr	r5, [sp, #20]
  _i2c = false;
  
  spi = spiInstance;
   804bc:	6781      	str	r1, [r0, #120]	; 0x78
  xmChipSelect   = xmCS;
  
  //Save SPI Channel information
  gyroSpiChannel = gyroCH;
  xmSpiChannel   = xmCH;
  spiClock		 = 800000L;
   804be:	490f      	ldr	r1, [pc, #60]	; (804fc <_ZN7LSM9DS0C1EP8SPIClassmmmmml+0x48>)
  gyroChipSelect = gyroCS;
  xmChipSelect   = xmCS;
  
  //Save SPI Channel information
  gyroSpiChannel = gyroCH;
  xmSpiChannel   = xmCH;
   804c0:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
  spiClock		 = 800000L;
  spiConfiguration = spiSettings;
   804c4:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
/***************************************************************************
 CONSTRUCTOR
 ***************************************************************************/

/** Hardware SPI Interface **/
LSM9DS0::LSM9DS0(SPIClass* spiInstance, uint32_t spiSettings, uint32_t xmCH, uint32_t xmCS, uint32_t gyroCH, uint32_t gyroCS, int32_t sensorID) {
   804c8:	2300      	movs	r3, #0
  _i2c = false;
   804ca:	2200      	movs	r2, #0
  
  spi = spiInstance;
  
  //Save hardware pin
  gyroChipSelect = gyroCS;
   804cc:	f8c0 7090 	str.w	r7, [r0, #144]	; 0x90
  xmChipSelect   = xmCS;
   804d0:	f8c0 6094 	str.w	r6, [r0, #148]	; 0x94
  
  //Save SPI Channel information
  gyroSpiChannel = gyroCH;
   804d4:	f8c0 5088 	str.w	r5, [r0, #136]	; 0x88
 CONSTRUCTOR
 ***************************************************************************/

/** Hardware SPI Interface **/
LSM9DS0::LSM9DS0(SPIClass* spiInstance, uint32_t spiSettings, uint32_t xmCH, uint32_t xmCS, uint32_t gyroCH, uint32_t gyroCS, int32_t sensorID) {
  _i2c = false;
   804d8:	f880 2074 	strb.w	r2, [r0, #116]	; 0x74
  xmChipSelect   = xmCS;
  
  //Save SPI Channel information
  gyroSpiChannel = gyroCH;
  xmSpiChannel   = xmCH;
  spiClock		 = 800000L;
   804dc:	f8c0 1084 	str.w	r1, [r0, #132]	; 0x84
/***************************************************************************
 CONSTRUCTOR
 ***************************************************************************/

/** Hardware SPI Interface **/
LSM9DS0::LSM9DS0(SPIClass* spiInstance, uint32_t spiSettings, uint32_t xmCH, uint32_t xmCS, uint32_t gyroCH, uint32_t gyroCS, int32_t sensorID) {
   804e0:	f8c0 309c 	str.w	r3, [r0, #156]	; 0x9c
   804e4:	f8c0 30a0 	str.w	r3, [r0, #160]	; 0xa0
   804e8:	f8c0 30a4 	str.w	r3, [r0, #164]	; 0xa4
   804ec:	f8c0 30a8 	str.w	r3, [r0, #168]	; 0xa8
   804f0:	f8c0 30ac 	str.w	r3, [r0, #172]	; 0xac
   804f4:	f8c0 30b0 	str.w	r3, [r0, #176]	; 0xb0
  //Save SPI Channel information
  gyroSpiChannel = gyroCH;
  xmSpiChannel   = xmCH;
  spiClock		 = 800000L;
  spiConfiguration = spiSettings;
}
   804f8:	bcf0      	pop	{r4, r5, r6, r7}
   804fa:	4770      	bx	lr
   804fc:	000c3500 	.word	0x000c3500

00080500 <_Z7pinModemm>:

#include "../libraries.h"


//Digital I/O
void pinMode(uint32_t pin, uint32_t value){
   80500:	b510      	push	{r4, lr}
	switch (value){
   80502:	2901      	cmp	r1, #1

#include "../libraries.h"


//Digital I/O
void pinMode(uint32_t pin, uint32_t value){
   80504:	b082      	sub	sp, #8
	switch (value){
   80506:	d020      	beq.n	8054a <_Z7pinModemm+0x4a>
   80508:	d310      	bcc.n	8052c <_Z7pinModemm+0x2c>
   8050a:	2902      	cmp	r1, #2
   8050c:	d10c      	bne.n	80528 <_Z7pinModemm+0x28>
		break;
		
		case INPUT_PULLUP:
		PIO_configurePin(
		pinCharacteristic[pin].port,
		pinCharacteristic[pin].pinMask,
   8050e:	4b16      	ldr	r3, [pc, #88]	; (80568 <_Z7pinModemm+0x68>)
   80510:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
   80514:	0080      	lsls	r0, r0, #2
   80516:	181a      	adds	r2, r3, r0
		PIO_INPUT,
		PIO_PULLUP, NONE);
   80518:	5818      	ldr	r0, [r3, r0]
   8051a:	2300      	movs	r3, #0
   8051c:	6851      	ldr	r1, [r2, #4]
   8051e:	4c13      	ldr	r4, [pc, #76]	; (8056c <_Z7pinModemm+0x6c>)
   80520:	9300      	str	r3, [sp, #0]
   80522:	2203      	movs	r2, #3
   80524:	2301      	movs	r3, #1
   80526:	47a0      	blx	r4
		break;
		
		default: break;
	}
}
   80528:	b002      	add	sp, #8
   8052a:	bd10      	pop	{r4, pc}
		case OUTPUT:
		PIO_configurePin(
		pinCharacteristic[pin].port,
		pinCharacteristic[pin].pinMask,
		PIO_OUTPUT_1,
		pinCharacteristic[pin].pinConfiguration, NONE);
   8052c:	4b0e      	ldr	r3, [pc, #56]	; (80568 <_Z7pinModemm+0x68>)
   8052e:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
   80532:	0080      	lsls	r0, r0, #2
   80534:	181a      	adds	r2, r3, r0
   80536:	6851      	ldr	r1, [r2, #4]
   80538:	5818      	ldr	r0, [r3, r0]
   8053a:	6913      	ldr	r3, [r2, #16]
   8053c:	2200      	movs	r2, #0
   8053e:	9200      	str	r2, [sp, #0]
   80540:	4c0a      	ldr	r4, [pc, #40]	; (8056c <_Z7pinModemm+0x6c>)
   80542:	2205      	movs	r2, #5
   80544:	47a0      	blx	r4
		PIO_PULLUP, NONE);
		break;
		
		default: break;
	}
}
   80546:	b002      	add	sp, #8
   80548:	bd10      	pop	{r4, pc}
		case INPUT:
		PIO_configurePin(
		pinCharacteristic[pin].port,
		pinCharacteristic[pin].pinMask,
		PIO_INPUT,
		pinCharacteristic[pin].pinConfiguration, NONE);
   8054a:	4b07      	ldr	r3, [pc, #28]	; (80568 <_Z7pinModemm+0x68>)
   8054c:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
   80550:	0080      	lsls	r0, r0, #2
   80552:	181a      	adds	r2, r3, r0
   80554:	6851      	ldr	r1, [r2, #4]
   80556:	5818      	ldr	r0, [r3, r0]
   80558:	6913      	ldr	r3, [r2, #16]
   8055a:	2200      	movs	r2, #0
   8055c:	9200      	str	r2, [sp, #0]
   8055e:	4c03      	ldr	r4, [pc, #12]	; (8056c <_Z7pinModemm+0x6c>)
   80560:	2203      	movs	r2, #3
   80562:	47a0      	blx	r4
		PIO_PULLUP, NONE);
		break;
		
		default: break;
	}
}
   80564:	b002      	add	sp, #8
   80566:	bd10      	pop	{r4, pc}
   80568:	000815e4 	.word	0x000815e4
   8056c:	000805b9 	.word	0x000805b9

00080570 <_Z12digitalWritemm>:
		default: return 0xFFFFFFFF;
	}
}

void digitalWrite(uint32_t pin, uint32_t value){
	switch (value){
   80570:	b159      	cbz	r1, 8058a <_Z12digitalWritemm+0x1a>
   80572:	2901      	cmp	r1, #1
   80574:	d108      	bne.n	80588 <_Z12digitalWritemm+0x18>
		case HIGH:
		PIO_setPin(pinCharacteristic[pin].port, pinCharacteristic[pin].pinMask);
   80576:	4b09      	ldr	r3, [pc, #36]	; (8059c <_Z12digitalWritemm+0x2c>)
   80578:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
   8057c:	0080      	lsls	r0, r0, #2
   8057e:	181a      	adds	r2, r3, r0
   80580:	6851      	ldr	r1, [r2, #4]
   80582:	5818      	ldr	r0, [r3, r0]
   80584:	4b06      	ldr	r3, [pc, #24]	; (805a0 <_Z12digitalWritemm+0x30>)
   80586:	4718      	bx	r3
   80588:	4770      	bx	lr
		break;
		
		case LOW:
		PIO_clearPin(pinCharacteristic[pin].port, pinCharacteristic[pin].pinMask);
   8058a:	4b04      	ldr	r3, [pc, #16]	; (8059c <_Z12digitalWritemm+0x2c>)
   8058c:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
   80590:	0080      	lsls	r0, r0, #2
   80592:	181a      	adds	r2, r3, r0
   80594:	6851      	ldr	r1, [r2, #4]
   80596:	5818      	ldr	r0, [r3, r0]
   80598:	4b02      	ldr	r3, [pc, #8]	; (805a4 <_Z12digitalWritemm+0x34>)
   8059a:	4718      	bx	r3
   8059c:	000815e4 	.word	0x000815e4
   805a0:	000805a9 	.word	0x000805a9
   805a4:	000805b1 	.word	0x000805b1

000805a8 <_Z10PIO_setPinP3Piom>:
	port->PIO_ODR=pinMask;
	port->PIO_PER=pinMask;
}

extern void PIO_setPin(Pio* port, const uint32_t pinMask){
	port->PIO_SODR |= pinMask;
   805a8:	6b03      	ldr	r3, [r0, #48]	; 0x30
   805aa:	4319      	orrs	r1, r3
   805ac:	6301      	str	r1, [r0, #48]	; 0x30
   805ae:	4770      	bx	lr

000805b0 <_Z12PIO_clearPinP3Piom>:
}

extern void PIO_clearPin(Pio* port, const uint32_t pinMask){
	port->PIO_CODR |= pinMask;
   805b0:	6b43      	ldr	r3, [r0, #52]	; 0x34
   805b2:	4319      	orrs	r1, r3
   805b4:	6341      	str	r1, [r0, #52]	; 0x34
   805b6:	4770      	bx	lr

000805b8 <_Z16PIO_configurePinP3Piom8_pioTypemm>:
*	\param port Port of the pin: pinCharacteristic[pin#].port
*	\param pinMask Bitmask of the pin: pinCharacteristic[pin#].pin
*	\param type Defines what type of pin you set it to: peripheral, input, or output
*	\param attribute Defines if the pin is digital, analog, or both: pinCharacteristic[pin#].pinAttribute
*/
extern uint32_t PIO_configurePin(Pio* port, const uint32_t pinMask, const EpioType type, const uint32_t attribute, const uint32_t ioMode){
   805b8:	b510      	push	{r4, lr}
	switch (type){
   805ba:	1e54      	subs	r4, r2, #1
   805bc:	2c04      	cmp	r4, #4
   805be:	d859      	bhi.n	80674 <_Z16PIO_configurePinP3Piom8_pioTypemm+0xbc>
   805c0:	e8df f004 	tbb	[pc, r4]
   805c4:	031a2e2e 	.word	0x031a2e2e
   805c8:	03          	.byte	0x03
   805c9:	00          	.byte	0x00
extern void PIO_pullUpDisable(Pio* port, const uint32_t pinMask){
	port->PIO_PUDR |= pinMask;
}

extern void PIO_disableInterrupt(Pio* port, const uint32_t pinMask){
	port->PIO_IDR |= pinMask;
   805ca:	6c44      	ldr	r4, [r0, #68]	; 0x44

extern void PIO_setOutput(Pio* port, const uint32_t pinMask, const uint32_t defaultValue,
const uint32_t multiDriveEN, const uint32_t pullUpEN){
	
	PIO_disableInterrupt(port, pinMask);
	switch (pullUpEN){
   805cc:	2b01      	cmp	r3, #1
extern void PIO_pullUpDisable(Pio* port, const uint32_t pinMask){
	port->PIO_PUDR |= pinMask;
}

extern void PIO_disableInterrupt(Pio* port, const uint32_t pinMask){
	port->PIO_IDR |= pinMask;
   805ce:	ea44 0401 	orr.w	r4, r4, r1
   805d2:	6444      	str	r4, [r0, #68]	; 0x44

extern void PIO_setOutput(Pio* port, const uint32_t pinMask, const uint32_t defaultValue,
const uint32_t multiDriveEN, const uint32_t pullUpEN){
	
	PIO_disableInterrupt(port, pinMask);
	switch (pullUpEN){
   805d4:	d03f      	beq.n	80656 <_Z16PIO_configurePinP3Piom8_pioTypemm+0x9e>
extern void PIO_pullUpEnable(Pio* port, const uint32_t pinMask){
	port->PIO_PUER |= pinMask;
}

extern void PIO_pullUpDisable(Pio* port, const uint32_t pinMask){
	port->PIO_PUDR |= pinMask;
   805d6:	6e04      	ldr	r4, [r0, #96]	; 0x60
		break;
		default: PIO_pullUpDisable(port, pinMask);
	}
	
	//Enable multi-drive if necessary
	switch (multiDriveEN){
   805d8:	2b04      	cmp	r3, #4
extern void PIO_pullUpEnable(Pio* port, const uint32_t pinMask){
	port->PIO_PUER |= pinMask;
}

extern void PIO_pullUpDisable(Pio* port, const uint32_t pinMask){
	port->PIO_PUDR |= pinMask;
   805da:	ea44 0401 	orr.w	r4, r4, r1
   805de:	6604      	str	r4, [r0, #96]	; 0x60
		break;
		default: PIO_pullUpDisable(port, pinMask);
	}
	
	//Enable multi-drive if necessary
	switch (multiDriveEN){
   805e0:	d13c      	bne.n	8065c <_Z16PIO_configurePinP3Piom8_pioTypemm+0xa4>
		case PIO_OPENDRAIN:
		port->PIO_MDER=pinMask;
   805e2:	6501      	str	r1, [r0, #80]	; 0x50
		break;
		default: port->PIO_MDDR=pinMask;
	}
	
	//Set the default output value
	switch (defaultValue){
   805e4:	2a05      	cmp	r2, #5
		PIO_setOutput(port, pinMask, type, attribute, attribute);
		break;
		
		default: return 0;
	}
	return 1;
   805e6:	f04f 0301 	mov.w	r3, #1
	}
	
	//Set the default output value
	switch (defaultValue){
		case PIO_OUTPUT_1:
		port->PIO_SODR=pinMask;
   805ea:	bf0c      	ite	eq
   805ec:	6301      	streq	r1, [r0, #48]	; 0x30
		break;
		default: port->PIO_CODR=pinMask;
   805ee:	6341      	strne	r1, [r0, #52]	; 0x34
	}
	
	//Configure pin as output
	port->PIO_OER=pinMask;
   805f0:	6101      	str	r1, [r0, #16]
	port->PIO_PER=pinMask;
   805f2:	6001      	str	r1, [r0, #0]
		break;
		
		default: return 0;
	}
	return 1;
}
   805f4:	4618      	mov	r0, r3
   805f6:	bd10      	pop	{r4, pc}
extern void PIO_pullUpDisable(Pio* port, const uint32_t pinMask){
	port->PIO_PUDR |= pinMask;
}

extern void PIO_disableInterrupt(Pio* port, const uint32_t pinMask){
	port->PIO_IDR |= pinMask;
   805f8:	6c42      	ldr	r2, [r0, #68]	; 0x44
extern void PIO_setInput(Pio* port, const uint32_t pinMask, const uint32_t attribute){
	PIO_disableInterrupt(port, pinMask);
	PIO_pullUpEnable(port, pinMask);
	
	//Enable de-glitch and de-bounce if necessary
	switch (attribute){
   805fa:	2b02      	cmp	r3, #2
extern void PIO_pullUpDisable(Pio* port, const uint32_t pinMask){
	port->PIO_PUDR |= pinMask;
}

extern void PIO_disableInterrupt(Pio* port, const uint32_t pinMask){
	port->PIO_IDR |= pinMask;
   805fc:	ea42 0201 	orr.w	r2, r2, r1
   80600:	6442      	str	r2, [r0, #68]	; 0x44
extern void PIO_clearPin(Pio* port, const uint32_t pinMask){
	port->PIO_CODR |= pinMask;
}

extern void PIO_pullUpEnable(Pio* port, const uint32_t pinMask){
	port->PIO_PUER |= pinMask;
   80602:	6e42      	ldr	r2, [r0, #100]	; 0x64
   80604:	ea42 0201 	orr.w	r2, r2, r1
   80608:	6642      	str	r2, [r0, #100]	; 0x64
extern void PIO_setInput(Pio* port, const uint32_t pinMask, const uint32_t attribute){
	PIO_disableInterrupt(port, pinMask);
	PIO_pullUpEnable(port, pinMask);
	
	//Enable de-glitch and de-bounce if necessary
	switch (attribute){
   8060a:	d02d      	beq.n	80668 <_Z16PIO_configurePinP3Piom8_pioTypemm+0xb0>
   8060c:	2b08      	cmp	r3, #8
   8060e:	d12f      	bne.n	80670 <_Z16PIO_configurePinP3Piom8_pioTypemm+0xb8>
		port->PIO_IFER=pinMask;
		port->PIO_SCIFSR=pinMask;
		break;
		
		case PIO_DEBOUNCE:
		port->PIO_IFER=pinMask;
   80610:	6201      	str	r1, [r0, #32]
		port->PIO_DIFSR=pinMask;
   80612:	f8c0 1084 	str.w	r1, [r0, #132]	; 0x84
		port->PIO_IFDR=pinMask;
		break;
	}
	
	//Configure pin as input
	port->PIO_ODR=pinMask;
   80616:	6141      	str	r1, [r0, #20]
		PIO_setOutput(port, pinMask, type, attribute, attribute);
		break;
		
		default: return 0;
	}
	return 1;
   80618:	2301      	movs	r3, #1
		break;
	}
	
	//Configure pin as input
	port->PIO_ODR=pinMask;
	port->PIO_PER=pinMask;
   8061a:	6001      	str	r1, [r0, #0]
		break;
		
		default: return 0;
	}
	return 1;
}
   8061c:	4618      	mov	r0, r3
   8061e:	bd10      	pop	{r4, pc}
*/
extern uint32_t PIO_configurePin(Pio* port, const uint32_t pinMask, const EpioType type, const uint32_t attribute, const uint32_t ioMode){
	switch (type){
		case PIO_PERIPH_A:
		case PIO_PERIPH_B:
		if(ioMode == OUTPUT) port->PIO_OER |= pinMask; //Enables output mode independent of peripheral selection
   80620:	9b02      	ldr	r3, [sp, #8]
   80622:	b1eb      	cbz	r3, 80660 <_Z16PIO_configurePinP3Piom8_pioTypemm+0xa8>
		if(ioMode == INPUT)  port->PIO_ODR |= pinMask; //Enables input mode independent of peripheral selection
   80624:	2b01      	cmp	r3, #1
   80626:	d102      	bne.n	8062e <_Z16PIO_configurePinP3Piom8_pioTypemm+0x76>
   80628:	6943      	ldr	r3, [r0, #20]
   8062a:	430b      	orrs	r3, r1
   8062c:	6143      	str	r3, [r0, #20]
	port->PIO_IER |= pinMask;
}

extern void PIO_setPeripheral(Pio* port, const uint32_t pinMask, const EpioType type){
	//Disable interrupts on pin
	port->PIO_IDR |= pinMask;
   8062e:	6c43      	ldr	r3, [r0, #68]	; 0x44
	//Turn off PIO control of pin and hand control to peripheral
	port->PIO_PDR |= pinMask;
	
	switch (type){
   80630:	2a02      	cmp	r2, #2
	port->PIO_IER |= pinMask;
}

extern void PIO_setPeripheral(Pio* port, const uint32_t pinMask, const EpioType type){
	//Disable interrupts on pin
	port->PIO_IDR |= pinMask;
   80632:	ea43 0301 	orr.w	r3, r3, r1
   80636:	6443      	str	r3, [r0, #68]	; 0x44
	//Turn off PIO control of pin and hand control to peripheral
	port->PIO_PDR |= pinMask;
   80638:	6843      	ldr	r3, [r0, #4]
   8063a:	ea43 0301 	orr.w	r3, r3, r1
   8063e:	6043      	str	r3, [r0, #4]
		case PIO_PERIPH_A:
		port->PIO_ABSR &= ~pinMask;
		break;
		
		case PIO_PERIPH_B:
		port->PIO_ABSR |=  pinMask;
   80640:	6f03      	ldr	r3, [r0, #112]	; 0x70
	//Turn off PIO control of pin and hand control to peripheral
	port->PIO_PDR |= pinMask;
	
	switch (type){
		case PIO_PERIPH_A:
		port->PIO_ABSR &= ~pinMask;
   80642:	bf14      	ite	ne
   80644:	438b      	bicne	r3, r1
		break;
		
		case PIO_PERIPH_B:
		port->PIO_ABSR |=  pinMask;
   80646:	430b      	orreq	r3, r1
   80648:	6703      	str	r3, [r0, #112]	; 0x70
extern void PIO_clearPin(Pio* port, const uint32_t pinMask){
	port->PIO_CODR |= pinMask;
}

extern void PIO_pullUpEnable(Pio* port, const uint32_t pinMask){
	port->PIO_PUER |= pinMask;
   8064a:	6e42      	ldr	r2, [r0, #100]	; 0x64
		PIO_setOutput(port, pinMask, type, attribute, attribute);
		break;
		
		default: return 0;
	}
	return 1;
   8064c:	2301      	movs	r3, #1
extern void PIO_clearPin(Pio* port, const uint32_t pinMask){
	port->PIO_CODR |= pinMask;
}

extern void PIO_pullUpEnable(Pio* port, const uint32_t pinMask){
	port->PIO_PUER |= pinMask;
   8064e:	4311      	orrs	r1, r2
   80650:	6641      	str	r1, [r0, #100]	; 0x64
		break;
		
		default: return 0;
	}
	return 1;
}
   80652:	4618      	mov	r0, r3
   80654:	bd10      	pop	{r4, pc}
extern void PIO_clearPin(Pio* port, const uint32_t pinMask){
	port->PIO_CODR |= pinMask;
}

extern void PIO_pullUpEnable(Pio* port, const uint32_t pinMask){
	port->PIO_PUER |= pinMask;
   80656:	6e43      	ldr	r3, [r0, #100]	; 0x64
   80658:	430b      	orrs	r3, r1
   8065a:	6643      	str	r3, [r0, #100]	; 0x64
	//Enable multi-drive if necessary
	switch (multiDriveEN){
		case PIO_OPENDRAIN:
		port->PIO_MDER=pinMask;
		break;
		default: port->PIO_MDDR=pinMask;
   8065c:	6541      	str	r1, [r0, #84]	; 0x54
   8065e:	e7c1      	b.n	805e4 <_Z16PIO_configurePinP3Piom8_pioTypemm+0x2c>
*/
extern uint32_t PIO_configurePin(Pio* port, const uint32_t pinMask, const EpioType type, const uint32_t attribute, const uint32_t ioMode){
	switch (type){
		case PIO_PERIPH_A:
		case PIO_PERIPH_B:
		if(ioMode == OUTPUT) port->PIO_OER |= pinMask; //Enables output mode independent of peripheral selection
   80660:	6903      	ldr	r3, [r0, #16]
   80662:	430b      	orrs	r3, r1
   80664:	6103      	str	r3, [r0, #16]
   80666:	e7e2      	b.n	8062e <_Z16PIO_configurePinP3Piom8_pioTypemm+0x76>
	PIO_pullUpEnable(port, pinMask);
	
	//Enable de-glitch and de-bounce if necessary
	switch (attribute){
		case PIO_DEGLITCH:
		port->PIO_IFER=pinMask;
   80668:	6201      	str	r1, [r0, #32]
		port->PIO_SCIFSR=pinMask;
   8066a:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
   8066e:	e7d2      	b.n	80616 <_Z16PIO_configurePinP3Piom8_pioTypemm+0x5e>
		port->PIO_IFER=pinMask;
		port->PIO_DIFSR=pinMask;
		break;
		
		default: //Glitch Input Filter Disable
		port->PIO_IFDR=pinMask;
   80670:	6241      	str	r1, [r0, #36]	; 0x24
   80672:	e7d0      	b.n	80616 <_Z16PIO_configurePinP3Piom8_pioTypemm+0x5e>
		case PIO_OUTPUT_0:
		case PIO_OUTPUT_1:
		PIO_setOutput(port, pinMask, type, attribute, attribute);
		break;
		
		default: return 0;
   80674:	2300      	movs	r3, #0
   80676:	e7d1      	b.n	8061c <_Z16PIO_configurePinP3Piom8_pioTypemm+0x64>

00080678 <pmc_enable_periph_clk>:
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
   80678:	282c      	cmp	r0, #44	; 0x2c
   8067a:	d819      	bhi.n	806b0 <pmc_enable_periph_clk+0x38>
		return 1;
	}

	if (ul_id < 32) {
   8067c:	281f      	cmp	r0, #31
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
   8067e:	4a0e      	ldr	r2, [pc, #56]	; (806b8 <pmc_enable_periph_clk+0x40>)
{
	if (ul_id > MAX_PERIPH_ID) {
		return 1;
	}

	if (ul_id < 32) {
   80680:	d809      	bhi.n	80696 <pmc_enable_periph_clk+0x1e>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
   80682:	2301      	movs	r3, #1
   80684:	6991      	ldr	r1, [r2, #24]
   80686:	fa03 f000 	lsl.w	r0, r3, r0
   8068a:	ea30 0301 	bics.w	r3, r0, r1
   8068e:	d011      	beq.n	806b4 <pmc_enable_periph_clk+0x3c>
			PMC->PMC_PCER0 = 1 << ul_id;
   80690:	6110      	str	r0, [r2, #16]
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
			PMC->PMC_PCER1 = 1 << ul_id;
		}
	}

	return 0;
   80692:	2000      	movs	r0, #0
   80694:	4770      	bx	lr
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
			PMC->PMC_PCER0 = 1 << ul_id;
		}
	} else {
		ul_id -= 32;
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
   80696:	2301      	movs	r3, #1
	if (ul_id < 32) {
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
			PMC->PMC_PCER0 = 1 << ul_id;
		}
	} else {
		ul_id -= 32;
   80698:	3820      	subs	r0, #32
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
   8069a:	f8d2 1108 	ldr.w	r1, [r2, #264]	; 0x108
   8069e:	fa03 f000 	lsl.w	r0, r3, r0
   806a2:	ea30 0301 	bics.w	r3, r0, r1
   806a6:	d005      	beq.n	806b4 <pmc_enable_periph_clk+0x3c>
			PMC->PMC_PCER1 = 1 << ul_id;
   806a8:	f8c2 0100 	str.w	r0, [r2, #256]	; 0x100
		}
	}

	return 0;
   806ac:	2000      	movs	r0, #0
   806ae:	4770      	bx	lr
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
		return 1;
   806b0:	2001      	movs	r0, #1
   806b2:	4770      	bx	lr
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
			PMC->PMC_PCER1 = 1 << ul_id;
		}
	}

	return 0;
   806b4:	2000      	movs	r0, #0
}
   806b6:	4770      	bx	lr
   806b8:	400e0600 	.word	0x400e0600

000806bc <_ZN15RingBufferClassC1Ev>:
 */ 

#include "../libraries.h"

//Constructor -- Unused except for friend classes
RingBufferClass::RingBufferClass(void){}
   806bc:	4770      	bx	lr
   806be:	bf00      	nop

000806c0 <_ZN15RingBufferClassC1EPmm>:

//Constructor -- Used for object instantiation
RingBufferClass::RingBufferClass(uint32_t *buffer, uint32_t bufferLength){
   806c0:	b510      	push	{r4, lr}
   806c2:	4604      	mov	r4, r0
	writeLocation = 0;
   806c4:	2300      	movs	r3, #0
   806c6:	60c3      	str	r3, [r0, #12]
	readLocation = 0;
   806c8:	6083      	str	r3, [r0, #8]
	bufferedData = 0;
   806ca:	6103      	str	r3, [r0, #16]
	
	bufferSize = bufferLength;
   806cc:	6042      	str	r2, [r0, #4]
	ringBuffer = buffer;

	memset((void *)ringBuffer, 0, bufferSize);
   806ce:	6842      	ldr	r2, [r0, #4]
	writeLocation = 0;
	readLocation = 0;
	bufferedData = 0;
	
	bufferSize = bufferLength;
	ringBuffer = buffer;
   806d0:	6001      	str	r1, [r0, #0]

	memset((void *)ringBuffer, 0, bufferSize);
   806d2:	4608      	mov	r0, r1
   806d4:	4619      	mov	r1, r3
   806d6:	4b02      	ldr	r3, [pc, #8]	; (806e0 <_ZN15RingBufferClassC1EPmm+0x20>)
   806d8:	4798      	blx	r3
}
   806da:	4620      	mov	r0, r4
   806dc:	bd10      	pop	{r4, pc}
   806de:	bf00      	nop
   806e0:	0008145d 	.word	0x0008145d

000806e4 <_ZN15RingBufferClass5flushEv>:

//Destroys all data and sets buffer to zero
void RingBufferClass::flush(){
	readLocation = 0;
   806e4:	2100      	movs	r1, #0
   806e6:	6081      	str	r1, [r0, #8]
	writeLocation = 0;
   806e8:	60c1      	str	r1, [r0, #12]
	bufferedData = 0;
   806ea:	6101      	str	r1, [r0, #16]
	memset((void *)ringBuffer, 0, bufferSize);
   806ec:	6842      	ldr	r2, [r0, #4]
   806ee:	4b01      	ldr	r3, [pc, #4]	; (806f4 <_ZN15RingBufferClass5flushEv+0x10>)
   806f0:	6800      	ldr	r0, [r0, #0]
   806f2:	4718      	bx	r3
   806f4:	0008145d 	.word	0x0008145d

000806f8 <_ZN15RingBufferClass5writeEm>:
}

//Stores a single word to the ringBuffer
uint32_t RingBufferClass::write(uint32_t data){
   806f8:	4603      	mov	r3, r0
    return bufferedData;
}

//Returns how many words can be stored into the buffer
uint32_t RingBufferClass::availableToWrite(){
	return bufferSize - bufferedData;
   806fa:	6840      	ldr	r0, [r0, #4]
   806fc:	691a      	ldr	r2, [r3, #16]
}

//Stores a single word to the ringBuffer
uint32_t RingBufferClass::write(uint32_t data){

	if(this->availableToWrite()){
   806fe:	4290      	cmp	r0, r2
   80700:	d019      	beq.n	80736 <_ZN15RingBufferClass5writeEm+0x3e>
		ringBuffer[writeLocation] = data;
   80702:	68d8      	ldr	r0, [r3, #12]
   80704:	681a      	ldr	r2, [r3, #0]
   80706:	f842 1020 	str.w	r1, [r2, r0, lsl #2]
		
		//Make sure the buffer fill count can't overrun bounds
		if((0<=bufferedData) && (bufferedData<bufferSize)){
   8070a:	691a      	ldr	r2, [r3, #16]
   8070c:	6919      	ldr	r1, [r3, #16]
   8070e:	685a      	ldr	r2, [r3, #4]
   80710:	4291      	cmp	r1, r2
   80712:	d20e      	bcs.n	80732 <_ZN15RingBufferClass5writeEm+0x3a>
			++bufferedData;
   80714:	691a      	ldr	r2, [r3, #16]
			writeLocation = (writeLocation + 1) % bufferSize;
   80716:	2001      	movs	r0, #1
	if(this->availableToWrite()){
		ringBuffer[writeLocation] = data;
		
		//Make sure the buffer fill count can't overrun bounds
		if((0<=bufferedData) && (bufferedData<bufferSize)){
			++bufferedData;
   80718:	4402      	add	r2, r0
	bufferedData = 0;
	memset((void *)ringBuffer, 0, bufferSize);
}

//Stores a single word to the ringBuffer
uint32_t RingBufferClass::write(uint32_t data){
   8071a:	b410      	push	{r4}
	if(this->availableToWrite()){
		ringBuffer[writeLocation] = data;
		
		//Make sure the buffer fill count can't overrun bounds
		if((0<=bufferedData) && (bufferedData<bufferSize)){
			++bufferedData;
   8071c:	611a      	str	r2, [r3, #16]
			writeLocation = (writeLocation + 1) % bufferSize;
   8071e:	68da      	ldr	r2, [r3, #12]
   80720:	685c      	ldr	r4, [r3, #4]
   80722:	4402      	add	r2, r0
   80724:	fbb2 f1f4 	udiv	r1, r2, r4
   80728:	fb04 2211 	mls	r2, r4, r1, r2
		}
		
		return 1u; //Success	
	} else
		return 0u; //Buffer full
}
   8072c:	bc10      	pop	{r4}
		ringBuffer[writeLocation] = data;
		
		//Make sure the buffer fill count can't overrun bounds
		if((0<=bufferedData) && (bufferedData<bufferSize)){
			++bufferedData;
			writeLocation = (writeLocation + 1) % bufferSize;
   8072e:	60da      	str	r2, [r3, #12]
		}
		
		return 1u; //Success	
	} else
		return 0u; //Buffer full
}
   80730:	4770      	bx	lr
		if((0<=bufferedData) && (bufferedData<bufferSize)){
			++bufferedData;
			writeLocation = (writeLocation + 1) % bufferSize;
		}
		
		return 1u; //Success	
   80732:	2001      	movs	r0, #1
	} else
		return 0u; //Buffer full
}
   80734:	4770      	bx	lr
			writeLocation = (writeLocation + 1) % bufferSize;
		}
		
		return 1u; //Success	
	} else
		return 0u; //Buffer full
   80736:	2000      	movs	r0, #0
   80738:	4770      	bx	lr
   8073a:	bf00      	nop

0008073c <_ZN15RingBufferClass4readEv>:
	
	return error;
}

//Reads a single word from the ringBuffer
uint32_t RingBufferClass::read(){
   8073c:	4603      	mov	r3, r0
	return ringBuffer[readLocation];
}

//Returns how many words can be read out of the buffer
uint32_t RingBufferClass::availableToRead(){
    return bufferedData;
   8073e:	6900      	ldr	r0, [r0, #16]

//Reads a single word from the ringBuffer
uint32_t RingBufferClass::read(){

	//If any data can be read out..
	if(this->availableToRead()){
   80740:	b1b0      	cbz	r0, 80770 <_ZN15RingBufferClass4readEv+0x34>
		uint32_t tempIndex = readLocation; //Save state
   80742:	6898      	ldr	r0, [r3, #8]
		

		//Make sure the buffer read count can't overrun bounds
		if((0<bufferedData) && (bufferedData<=bufferSize)){
   80744:	691a      	ldr	r2, [r3, #16]
   80746:	b1a2      	cbz	r2, 80772 <_ZN15RingBufferClass4readEv+0x36>
   80748:	6919      	ldr	r1, [r3, #16]
   8074a:	685a      	ldr	r2, [r3, #4]
   8074c:	4291      	cmp	r1, r2
   8074e:	d810      	bhi.n	80772 <_ZN15RingBufferClass4readEv+0x36>
			--bufferedData;
   80750:	691a      	ldr	r2, [r3, #16]
	
	return error;
}

//Reads a single word from the ringBuffer
uint32_t RingBufferClass::read(){
   80752:	b410      	push	{r4}
		uint32_t tempIndex = readLocation; //Save state
		

		//Make sure the buffer read count can't overrun bounds
		if((0<bufferedData) && (bufferedData<=bufferSize)){
			--bufferedData;
   80754:	3a01      	subs	r2, #1
   80756:	611a      	str	r2, [r3, #16]
			readLocation = (readLocation + 1) % bufferSize;
   80758:	689a      	ldr	r2, [r3, #8]
   8075a:	685c      	ldr	r4, [r3, #4]
   8075c:	3201      	adds	r2, #1
   8075e:	fbb2 f1f4 	udiv	r1, r2, r4
   80762:	fb04 2211 	mls	r2, r4, r1, r2
		}
		return ringBuffer[tempIndex];
	} else
		return 0u; //Buffer empty
}
   80766:	bc10      	pop	{r4}
		

		//Make sure the buffer read count can't overrun bounds
		if((0<bufferedData) && (bufferedData<=bufferSize)){
			--bufferedData;
			readLocation = (readLocation + 1) % bufferSize;
   80768:	609a      	str	r2, [r3, #8]
		}
		return ringBuffer[tempIndex];
   8076a:	681b      	ldr	r3, [r3, #0]
   8076c:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
	} else
		return 0u; //Buffer empty
}
   80770:	4770      	bx	lr
		//Make sure the buffer read count can't overrun bounds
		if((0<bufferedData) && (bufferedData<=bufferSize)){
			--bufferedData;
			readLocation = (readLocation + 1) % bufferSize;
		}
		return ringBuffer[tempIndex];
   80772:	681b      	ldr	r3, [r3, #0]
   80774:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
	} else
		return 0u; //Buffer empty
}
   80778:	4770      	bx	lr
   8077a:	bf00      	nop

0008077c <_ZN15RingBufferClass4peekEv>:

//Takes a peek at the value in the current readLocation without incrementing
uint32_t RingBufferClass::peek(){
	return ringBuffer[readLocation];
   8077c:	6882      	ldr	r2, [r0, #8]
   8077e:	6803      	ldr	r3, [r0, #0]
   80780:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
}
   80784:	4770      	bx	lr
   80786:	bf00      	nop

00080788 <_ZN15RingBufferClass15availableToReadEv>:

//Returns how many words can be read out of the buffer
uint32_t RingBufferClass::availableToRead(){
    return bufferedData;
   80788:	6900      	ldr	r0, [r0, #16]
}
   8078a:	4770      	bx	lr

0008078c <_ZN9SchedulerC1Ev>:

#include "../libraries.h"

Scheduler::Scheduler(){
	action[0].action = NULL;
	action[0].delay = 65535;
   8078c:	f64f 71ff 	movw	r1, #65535	; 0xffff
*/

#include "../libraries.h"

Scheduler::Scheduler(){
	action[0].action = NULL;
   80790:	2200      	movs	r2, #0
	action[0].delay = 65535;
   80792:	6081      	str	r1, [r0, #8]
*/

#include "../libraries.h"

Scheduler::Scheduler(){
	action[0].action = NULL;
   80794:	6002      	str	r2, [r0, #0]
	action[0].delay = 65535;
	action[0].time = 0;
   80796:	6042      	str	r2, [r0, #4]
	currentSize = 0;
   80798:	f880 2258 	strb.w	r2, [r0, #600]	; 0x258
}
   8079c:	4770      	bx	lr
   8079e:	bf00      	nop

000807a0 <_ZN9Scheduler6updateEv>:

//Check to see if it's time to call any of the functions
void Scheduler::update(){
   807a0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	//flush/update all
	for (uint8_t i=0; i<currentSize; i++){
   807a4:	f890 3258 	ldrb.w	r3, [r0, #600]	; 0x258
   807a8:	2b00      	cmp	r3, #0
   807aa:	f000 8086 	beq.w	808ba <_ZN9Scheduler6updateEv+0x11a>
   807ae:	4604      	mov	r4, r0
   807b0:	4d48      	ldr	r5, [pc, #288]	; (808d4 <_ZN9Scheduler6updateEv+0x134>)
   807b2:	2600      	movs	r6, #0
   807b4:	e008      	b.n	807c8 <_ZN9Scheduler6updateEv+0x28>
   807b6:	f894 0258 	ldrb.w	r0, [r4, #600]	; 0x258
   807ba:	f106 0c01 	add.w	ip, r6, #1
   807be:	fa5f f68c 	uxtb.w	r6, ip
   807c2:	4286      	cmp	r6, r0
   807c4:	f080 8083 	bcs.w	808ce <_ZN9Scheduler6updateEv+0x12e>
		//it is time to call the function associated with action[i]
		if ((millis() - action[i].time) > action[i].delay){
   807c8:	47a8      	blx	r5
   807ca:	ea4f 0946 	mov.w	r9, r6, lsl #1
   807ce:	eb09 0806 	add.w	r8, r9, r6
   807d2:	eb04 0788 	add.w	r7, r4, r8, lsl #2
   807d6:	687b      	ldr	r3, [r7, #4]
   807d8:	68ba      	ldr	r2, [r7, #8]
   807da:	1ac0      	subs	r0, r0, r3
   807dc:	4290      	cmp	r0, r2
   807de:	d9ea      	bls.n	807b6 <_ZN9Scheduler6updateEv+0x16>
			action[i].action(); //call function
   807e0:	f854 3028 	ldr.w	r3, [r4, r8, lsl #2]
   807e4:	4798      	blx	r3
			//this was the last action in queue
			if (i==0 && currentSize==1){ currentSize=0; }
   807e6:	f894 0258 	ldrb.w	r0, [r4, #600]	; 0x258
   807ea:	2e00      	cmp	r6, #0
   807ec:	d15d      	bne.n	808aa <_ZN9Scheduler6updateEv+0x10a>
   807ee:	2801      	cmp	r0, #1
   807f0:	d05f      	beq.n	808b2 <_ZN9Scheduler6updateEv+0x112>
			//this is the second action of two possible, only one left
			else if (i==1 && currentSize==2){ currentSize=1; }
			//the last action has executed, cut it off
			else if (i+1==currentSize){
   807f2:	f106 0c01 	add.w	ip, r6, #1
   807f6:	4584      	cmp	ip, r0
   807f8:	d061      	beq.n	808be <_ZN9Scheduler6updateEv+0x11e>
				currentSize--;
			}
			//all other elements
			else if (i+1<currentSize){ 
   807fa:	dae0      	bge.n	807be <_ZN9Scheduler6updateEv+0x1e>
	function action;
	unsigned long time;
	unsigned int delay;
	//assignment operator
	schedule_action_s& operator=(const schedule_action_s& rhs){
		action = rhs.action;
   807fc:	68fb      	ldr	r3, [r7, #12]
		time = rhs.time;
		delay = rhs.delay;
   807fe:	444e      	add	r6, r9
	function action;
	unsigned long time;
	unsigned int delay;
	//assignment operator
	schedule_action_s& operator=(const schedule_action_s& rhs){
		action = rhs.action;
   80800:	f844 3028 	str.w	r3, [r4, r8, lsl #2]
		time = rhs.time;
   80804:	693a      	ldr	r2, [r7, #16]
		delay = rhs.delay;
   80806:	eb0c 034c 	add.w	r3, ip, ip, lsl #1
	unsigned long time;
	unsigned int delay;
	//assignment operator
	schedule_action_s& operator=(const schedule_action_s& rhs){
		action = rhs.action;
		time = rhs.time;
   8080a:	607a      	str	r2, [r7, #4]
		delay = rhs.delay;
   8080c:	eb04 0383 	add.w	r3, r4, r3, lsl #2
   80810:	689b      	ldr	r3, [r3, #8]
   80812:	eb04 0686 	add.w	r6, r4, r6, lsl #2
   80816:	60b3      	str	r3, [r6, #8]
}

//Removes all redundant actions from memory
void Scheduler::defragment(){
	uint8_t defrag=0;
	for (uint8_t i=0; i<currentSize; i++){
   80818:	2800      	cmp	r0, #0
   8081a:	d04e      	beq.n	808ba <_ZN9Scheduler6updateEv+0x11a>
   8081c:	f04f 0e01 	mov.w	lr, #1
   80820:	e005      	b.n	8082e <_ZN9Scheduler6updateEv+0x8e>
   80822:	f10e 0701 	add.w	r7, lr, #1
   80826:	4586      	cmp	lr, r0
   80828:	b2ff      	uxtb	r7, r7
   8082a:	d2c8      	bcs.n	807be <_ZN9Scheduler6updateEv+0x1e>
   8082c:	46be      	mov	lr, r7
   8082e:	f10e 33ff 	add.w	r3, lr, #4294967295
   80832:	b2db      	uxtb	r3, r3
		if(i+1 < currentSize && action[i] == action[i+1]){
   80834:	1c5a      	adds	r2, r3, #1
   80836:	4282      	cmp	r2, r0
   80838:	daf3      	bge.n	80822 <_ZN9Scheduler6updateEv+0x82>
   8083a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   8083e:	eb04 0683 	add.w	r6, r4, r3, lsl #2
		return *this;
	}
	//boolean equality
	uint8_t operator==(const schedule_action_s& rhs) const{
		return (action == rhs.action && time == rhs.time && delay == rhs.delay);
   80842:	f854 1023 	ldr.w	r1, [r4, r3, lsl #2]
   80846:	68f3      	ldr	r3, [r6, #12]
   80848:	4299      	cmp	r1, r3
   8084a:	d1ea      	bne.n	80822 <_ZN9Scheduler6updateEv+0x82>
   8084c:	6871      	ldr	r1, [r6, #4]
   8084e:	6933      	ldr	r3, [r6, #16]
   80850:	4299      	cmp	r1, r3
   80852:	d1e6      	bne.n	80822 <_ZN9Scheduler6updateEv+0x82>
   80854:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   80858:	eb04 0382 	add.w	r3, r4, r2, lsl #2
   8085c:	689b      	ldr	r3, [r3, #8]
   8085e:	68b2      	ldr	r2, [r6, #8]
			defrag=i+1;
			while (defrag+1 < currentSize){
   80860:	f10e 0701 	add.w	r7, lr, #1
   80864:	429a      	cmp	r2, r3
   80866:	d1de      	bne.n	80826 <_ZN9Scheduler6updateEv+0x86>
   80868:	42b8      	cmp	r0, r7
   8086a:	463b      	mov	r3, r7
   8086c:	4672      	mov	r2, lr
   8086e:	dd17      	ble.n	808a0 <_ZN9Scheduler6updateEv+0x100>
   80870:	4639      	mov	r1, r7
   80872:	eb03 0343 	add.w	r3, r3, r3, lsl #1
	function action;
	unsigned long time;
	unsigned int delay;
	//assignment operator
	schedule_action_s& operator=(const schedule_action_s& rhs){
		action = rhs.action;
   80876:	f854 6023 	ldr.w	r6, [r4, r3, lsl #2]
   8087a:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   8087e:	f844 6022 	str.w	r6, [r4, r2, lsl #2]
   80882:	eb04 0383 	add.w	r3, r4, r3, lsl #2
		time = rhs.time;
   80886:	685e      	ldr	r6, [r3, #4]
   80888:	eb04 0882 	add.w	r8, r4, r2, lsl #2
   8088c:	f8c8 6004 	str.w	r6, [r8, #4]
				action[defrag] = action[defrag+1];
				defrag++;
   80890:	b2ca      	uxtb	r2, r1
		delay = rhs.delay;
   80892:	689b      	ldr	r3, [r3, #8]
void Scheduler::defragment(){
	uint8_t defrag=0;
	for (uint8_t i=0; i<currentSize; i++){
		if(i+1 < currentSize && action[i] == action[i+1]){
			defrag=i+1;
			while (defrag+1 < currentSize){
   80894:	1c51      	adds	r1, r2, #1
   80896:	4288      	cmp	r0, r1
   80898:	f8c8 3008 	str.w	r3, [r8, #8]
   8089c:	460b      	mov	r3, r1
   8089e:	dce8      	bgt.n	80872 <_ZN9Scheduler6updateEv+0xd2>
				action[defrag] = action[defrag+1];
				defrag++;
			}
			currentSize--;
   808a0:	3801      	subs	r0, #1
   808a2:	b2c0      	uxtb	r0, r0
   808a4:	f884 0258 	strb.w	r0, [r4, #600]	; 0x258
   808a8:	e7bd      	b.n	80826 <_ZN9Scheduler6updateEv+0x86>
		if ((millis() - action[i].time) > action[i].delay){
			action[i].action(); //call function
			//this was the last action in queue
			if (i==0 && currentSize==1){ currentSize=0; }
			//this is the second action of two possible, only one left
			else if (i==1 && currentSize==2){ currentSize=1; }
   808aa:	2e01      	cmp	r6, #1
   808ac:	d1a1      	bne.n	807f2 <_ZN9Scheduler6updateEv+0x52>
   808ae:	2802      	cmp	r0, #2
   808b0:	d19f      	bne.n	807f2 <_ZN9Scheduler6updateEv+0x52>
   808b2:	f884 6258 	strb.w	r6, [r4, #600]	; 0x258
   808b6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   808ba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			//the last action has executed, cut it off
			else if (i+1==currentSize){
				currentSize--;
   808be:	b2f0      	uxtb	r0, r6
}

//Check to see if it's time to call any of the functions
void Scheduler::update(){
	//flush/update all
	for (uint8_t i=0; i<currentSize; i++){
   808c0:	fa5f f68c 	uxtb.w	r6, ip
   808c4:	4286      	cmp	r6, r0
			if (i==0 && currentSize==1){ currentSize=0; }
			//this is the second action of two possible, only one left
			else if (i==1 && currentSize==2){ currentSize=1; }
			//the last action has executed, cut it off
			else if (i+1==currentSize){
				currentSize--;
   808c6:	f884 0258 	strb.w	r0, [r4, #600]	; 0x258
}

//Check to see if it's time to call any of the functions
void Scheduler::update(){
	//flush/update all
	for (uint8_t i=0; i<currentSize; i++){
   808ca:	f4ff af7d 	bcc.w	807c8 <_ZN9Scheduler6updateEv+0x28>
   808ce:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   808d2:	bf00      	nop
   808d4:	00080cb5 	.word	0x00080cb5

000808d8 <_ZN9Scheduler8scheduleEPFvvEj>:
		}
	}
}

//Schedule a functioncall in 'time' milliseconds.
void Scheduler::schedule(function userAction, unsigned int time){
   808d8:	b538      	push	{r3, r4, r5, lr}
	if (currentSize<NUMBER_OF_SCHEDULED_ACTIONS){
   808da:	f890 3258 	ldrb.w	r3, [r0, #600]	; 0x258
   808de:	2b31      	cmp	r3, #49	; 0x31
   808e0:	d80e      	bhi.n	80900 <_ZN9Scheduler8scheduleEPFvvEj+0x28>
   808e2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   808e6:	009b      	lsls	r3, r3, #2
   808e8:	18c5      	adds	r5, r0, r3
		action[currentSize].action = userAction;
   808ea:	50c1      	str	r1, [r0, r3]
		action[currentSize].delay = time;
		action[currentSize].time = millis();
   808ec:	4b05      	ldr	r3, [pc, #20]	; (80904 <_ZN9Scheduler8scheduleEPFvvEj+0x2c>)

//Schedule a functioncall in 'time' milliseconds.
void Scheduler::schedule(function userAction, unsigned int time){
	if (currentSize<NUMBER_OF_SCHEDULED_ACTIONS){
		action[currentSize].action = userAction;
		action[currentSize].delay = time;
   808ee:	60aa      	str	r2, [r5, #8]
   808f0:	4604      	mov	r4, r0
		action[currentSize].time = millis();
   808f2:	4798      	blx	r3
   808f4:	6068      	str	r0, [r5, #4]
		currentSize++;
   808f6:	f894 3258 	ldrb.w	r3, [r4, #600]	; 0x258
   808fa:	3301      	adds	r3, #1
   808fc:	f884 3258 	strb.w	r3, [r4, #600]	; 0x258
   80900:	bd38      	pop	{r3, r4, r5, pc}
   80902:	bf00      	nop
   80904:	00080cb5 	.word	0x00080cb5

00080908 <_ZN8SPIClassC1Ev>:
 *  Author: Brandon
 */ 

#include "../libraries.h"

SPIClass::SPIClass(){
   80908:	b510      	push	{r4, lr}
   8090a:	4604      	mov	r4, r0
   8090c:	4b14      	ldr	r3, [pc, #80]	; (80960 <_ZN8SPIClassC1Ev+0x58>)
   8090e:	4798      	blx	r3
   80910:	f104 0128 	add.w	r1, r4, #40	; 0x28
   80914:	f104 0068 	add.w	r0, r4, #104	; 0x68
   80918:	2210      	movs	r2, #16
   8091a:	4b12      	ldr	r3, [pc, #72]	; (80964 <_ZN8SPIClassC1Ev+0x5c>)
   8091c:	4798      	blx	r3
	spi = SPI0;
   8091e:	4912      	ldr	r1, [pc, #72]	; (80968 <_ZN8SPIClassC1Ev+0x60>)
	/** Ring Buffer Instantiation **/
	uint32_t _rxBuffer[16];
	RingBufferClass rxBuffer = RingBufferClass(_rxBuffer, 16);
	
	/** Settings for each channel **/
	struct csConfig{
   80920:	2300      	movs	r3, #0
	IRQnID = SPI0_IRQn;
   80922:	2218      	movs	r2, #24
 */ 

#include "../libraries.h"

SPIClass::SPIClass(){
	spi = SPI0;
   80924:	6161      	str	r1, [r4, #20]
   80926:	f884 3098 	strb.w	r3, [r4, #152]	; 0x98
   8092a:	f884 30bc 	strb.w	r3, [r4, #188]	; 0xbc
   8092e:	f884 30e0 	strb.w	r3, [r4, #224]	; 0xe0
   80932:	f884 3104 	strb.w	r3, [r4, #260]	; 0x104
   80936:	f884 3128 	strb.w	r3, [r4, #296]	; 0x128
   8093a:	f884 314c 	strb.w	r3, [r4, #332]	; 0x14c
   8093e:	f884 3170 	strb.w	r3, [r4, #368]	; 0x170
   80942:	f884 3194 	strb.w	r3, [r4, #404]	; 0x194
   80946:	f884 31b8 	strb.w	r3, [r4, #440]	; 0x1b8
   8094a:	f884 31dc 	strb.w	r3, [r4, #476]	; 0x1dc
   8094e:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200
   80952:	f884 3224 	strb.w	r3, [r4, #548]	; 0x224
	IRQnID = SPI0_IRQn;
   80956:	7622      	strb	r2, [r4, #24]
	periphID = ID_SPI0;
   80958:	61e2      	str	r2, [r4, #28]
}
   8095a:	4620      	mov	r0, r4
   8095c:	bd10      	pop	{r4, pc}
   8095e:	bf00      	nop
   80960:	000806bd 	.word	0x000806bd
   80964:	000806c1 	.word	0x000806c1
   80968:	40008000 	.word	0x40008000

0008096c <_ZN8SPIClass10IRQHandlerEv>:
void SPIClass::end(){
	SPI_Disable(SPI0);
	initialized = false; 
}

void SPIClass::IRQHandler(){
   8096c:	4770      	bx	lr
   8096e:	bf00      	nop

00080970 <_Z12TC_ConfigureP2Tcmm>:
 * \param pTc  Pointer to a Tc instance.
 * \param channel Channel number.
 * \param mode  Operating mode (TC_CMR [Channel Mode Register] value).
 */
extern void TC_Configure( Tc *pTc, uint32_t dwChannel, uint32_t dwMode )
{
   80970:	b430      	push	{r4, r5}
    TcChannel* pTcCh ;

    pTcCh = pTc->TC_CHANNEL+dwChannel ;
   80972:	0189      	lsls	r1, r1, #6
   80974:	1843      	adds	r3, r0, r1

    /*  Disable TC clock */
    pTcCh->TC_CCR = TC_CCR_CLKDIS ;
   80976:	2502      	movs	r5, #2

    /*  Disable interrupts */
    pTcCh->TC_IDR = 0xFFFFFFFF ;
   80978:	f04f 34ff 	mov.w	r4, #4294967295
    TcChannel* pTcCh ;

    pTcCh = pTc->TC_CHANNEL+dwChannel ;

    /*  Disable TC clock */
    pTcCh->TC_CCR = TC_CCR_CLKDIS ;
   8097c:	5045      	str	r5, [r0, r1]

    /*  Disable interrupts */
    pTcCh->TC_IDR = 0xFFFFFFFF ;
   8097e:	629c      	str	r4, [r3, #40]	; 0x28

    /*  Clear status register */
    pTcCh->TC_SR ;
   80980:	6a19      	ldr	r1, [r3, #32]

    /*  Set mode */
    pTcCh->TC_CMR = dwMode ;
}
   80982:	bc30      	pop	{r4, r5}

    /*  Clear status register */
    pTcCh->TC_SR ;

    /*  Set mode */
    pTcCh->TC_CMR = dwMode ;
   80984:	605a      	str	r2, [r3, #4]
}
   80986:	4770      	bx	lr

00080988 <_Z8TC_StartP2Tcm>:
 */
extern void TC_Start( Tc *pTc, uint32_t dwChannel )
{
    TcChannel* pTcCh ;

    pTcCh = pTc->TC_CHANNEL+dwChannel ;
   80988:	0189      	lsls	r1, r1, #6
    pTcCh->TC_CCR = TC_CCR_CLKEN | TC_CCR_SWTRG ;
   8098a:	2305      	movs	r3, #5
   8098c:	5043      	str	r3, [r0, r1]
   8098e:	4770      	bx	lr

00080990 <_Z17TC_FindMckDivisormmPmS_m>:
 * \param dwBoardMCK  Board clock frequency.
 *
 * \return 1 if a proper divisor has been found, otherwise 0.
 */
extern uint32_t TC_FindMckDivisor( uint32_t dwFreq, uint32_t dwMCk, uint32_t *dwDiv, uint32_t *dwTcClks, uint32_t dwBoardMCK )
{
   80990:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   80994:	b086      	sub	sp, #24
   80996:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    const uint32_t adwDivisors[5] = { 2, 8, 32, 128, dwBoardMCK / 32768 } ;
   80998:	2702      	movs	r7, #2
   8099a:	0bed      	lsrs	r5, r5, #15
   8099c:	2608      	movs	r6, #8
   8099e:	f04f 0c20 	mov.w	ip, #32
   809a2:	f04f 0e80 	mov.w	lr, #128	; 0x80

    uint32_t dwIndex = 0 ;

    /*  Satisfy lower bound */
    while ( dwFreq < ((dwMCk / adwDivisors[dwIndex]) / 65536) )
   809a6:	ebb0 4f51 	cmp.w	r0, r1, lsr #17
 *
 * \return 1 if a proper divisor has been found, otherwise 0.
 */
extern uint32_t TC_FindMckDivisor( uint32_t dwFreq, uint32_t dwMCk, uint32_t *dwDiv, uint32_t *dwTcClks, uint32_t dwBoardMCK )
{
    const uint32_t adwDivisors[5] = { 2, 8, 32, 128, dwBoardMCK / 32768 } ;
   809aa:	9505      	str	r5, [sp, #20]
   809ac:	9701      	str	r7, [sp, #4]
   809ae:	9602      	str	r6, [sp, #8]
   809b0:	f8cd c00c 	str.w	ip, [sp, #12]
   809b4:	f8cd e010 	str.w	lr, [sp, #16]
   809b8:	f04f 0400 	mov.w	r4, #0

    uint32_t dwIndex = 0 ;

    /*  Satisfy lower bound */
    while ( dwFreq < ((dwMCk / adwDivisors[dwIndex]) / 65536) )
   809bc:	d21c      	bcs.n	809f8 <_Z17TC_FindMckDivisormmPmS_m+0x68>
   809be:	ebb0 4fd1 	cmp.w	r0, r1, lsr #19
   809c2:	d248      	bcs.n	80a56 <_Z17TC_FindMckDivisormmPmS_m+0xc6>
   809c4:	ebb0 5f51 	cmp.w	r0, r1, lsr #21
   809c8:	d247      	bcs.n	80a5a <_Z17TC_FindMckDivisormmPmS_m+0xca>
   809ca:	ebb0 5fd1 	cmp.w	r0, r1, lsr #23
   809ce:	d247      	bcs.n	80a60 <_Z17TC_FindMckDivisormmPmS_m+0xd0>
   809d0:	fbb1 f1f5 	udiv	r1, r1, r5
   809d4:	ebb0 4f11 	cmp.w	r0, r1, lsr #16
   809d8:	d203      	bcs.n	809e2 <_Z17TC_FindMckDivisormmPmS_m+0x52>
        dwIndex++ ;

        /*  If no divisor can be found, return 0 */
        if ( dwIndex == (sizeof( adwDivisors )/sizeof( adwDivisors[0] ))  )
        {
            return 0 ;
   809da:	4620      	mov	r0, r4
    {
        *dwTcClks = dwIndex ;
    }

    return 1 ;
}
   809dc:	b006      	add	sp, #24
   809de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   809e2:	462e      	mov	r6, r5
   809e4:	2404      	movs	r4, #4
        }
        dwIndex++ ;
    }

    /*  Store results */
    if ( dwDiv )
   809e6:	b102      	cbz	r2, 809ea <_Z17TC_FindMckDivisormmPmS_m+0x5a>
    {
        *dwDiv = adwDivisors[dwIndex] ;
   809e8:	6016      	str	r6, [r2, #0]
    }
    if ( dwTcClks )
   809ea:	2b00      	cmp	r3, #0
   809ec:	d03b      	beq.n	80a66 <_Z17TC_FindMckDivisormmPmS_m+0xd6>
    {
        *dwTcClks = dwIndex ;
    }

    return 1 ;
   809ee:	2001      	movs	r0, #1
    {
        *dwDiv = adwDivisors[dwIndex] ;
    }
    if ( dwTcClks )
    {
        *dwTcClks = dwIndex ;
   809f0:	601c      	str	r4, [r3, #0]
    }

    return 1 ;
}
   809f2:	b006      	add	sp, #24
   809f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    const uint32_t adwDivisors[5] = { 2, 8, 32, 128, dwBoardMCK / 32768 } ;

    uint32_t dwIndex = 0 ;

    /*  Satisfy lower bound */
    while ( dwFreq < ((dwMCk / adwDivisors[dwIndex]) / 65536) )
   809f8:	463e      	mov	r6, r7

    /*  Try to maximize DIV while satisfying upper bound */
    while ( dwIndex < 4 )
    {

        if ( dwFreq > (dwMCk / adwDivisors[dwIndex + 1]) )
   809fa:	1c67      	adds	r7, r4, #1
   809fc:	f10d 0e18 	add.w	lr, sp, #24
   80a00:	eb0e 0e87 	add.w	lr, lr, r7, lsl #2
   80a04:	f85e cc14 	ldr.w	ip, [lr, #-20]
   80a08:	fbb1 fefc 	udiv	lr, r1, ip
   80a0c:	4570      	cmp	r0, lr
   80a0e:	d8ea      	bhi.n	809e6 <_Z17TC_FindMckDivisormmPmS_m+0x56>
            return 0 ;
        }
    }

    /*  Try to maximize DIV while satisfying upper bound */
    while ( dwIndex < 4 )
   80a10:	2f04      	cmp	r7, #4
   80a12:	d035      	beq.n	80a80 <_Z17TC_FindMckDivisormmPmS_m+0xf0>
    {

        if ( dwFreq > (dwMCk / adwDivisors[dwIndex + 1]) )
   80a14:	f104 0e02 	add.w	lr, r4, #2
   80a18:	ae06      	add	r6, sp, #24
   80a1a:	eb06 068e 	add.w	r6, r6, lr, lsl #2
   80a1e:	f856 8c14 	ldr.w	r8, [r6, #-20]
   80a22:	fbb1 f6f8 	udiv	r6, r1, r8
   80a26:	42b0      	cmp	r0, r6
   80a28:	d827      	bhi.n	80a7a <_Z17TC_FindMckDivisormmPmS_m+0xea>
            return 0 ;
        }
    }

    /*  Try to maximize DIV while satisfying upper bound */
    while ( dwIndex < 4 )
   80a2a:	f1be 0f04 	cmp.w	lr, #4
   80a2e:	d021      	beq.n	80a74 <_Z17TC_FindMckDivisormmPmS_m+0xe4>
    {

        if ( dwFreq > (dwMCk / adwDivisors[dwIndex + 1]) )
   80a30:	3403      	adds	r4, #3
   80a32:	ae06      	add	r6, sp, #24
   80a34:	eb06 0684 	add.w	r6, r6, r4, lsl #2
   80a38:	f856 6c14 	ldr.w	r6, [r6, #-20]
   80a3c:	fbb1 f7f6 	udiv	r7, r1, r6
   80a40:	42b8      	cmp	r0, r7
   80a42:	d814      	bhi.n	80a6e <_Z17TC_FindMckDivisormmPmS_m+0xde>
            return 0 ;
        }
    }

    /*  Try to maximize DIV while satisfying upper bound */
    while ( dwIndex < 4 )
   80a44:	2c04      	cmp	r4, #4
   80a46:	d010      	beq.n	80a6a <_Z17TC_FindMckDivisormmPmS_m+0xda>
    {

        if ( dwFreq > (dwMCk / adwDivisors[dwIndex + 1]) )
   80a48:	9c05      	ldr	r4, [sp, #20]
   80a4a:	fbb1 f1f4 	udiv	r1, r1, r4
   80a4e:	4288      	cmp	r0, r1
   80a50:	d9c7      	bls.n	809e2 <_Z17TC_FindMckDivisormmPmS_m+0x52>
   80a52:	2403      	movs	r4, #3
   80a54:	e7c7      	b.n	809e6 <_Z17TC_FindMckDivisormmPmS_m+0x56>
    uint32_t dwIndex = 0 ;

    /*  Satisfy lower bound */
    while ( dwFreq < ((dwMCk / adwDivisors[dwIndex]) / 65536) )
    {
        dwIndex++ ;
   80a56:	2401      	movs	r4, #1
   80a58:	e7cf      	b.n	809fa <_Z17TC_FindMckDivisormmPmS_m+0x6a>
    const uint32_t adwDivisors[5] = { 2, 8, 32, 128, dwBoardMCK / 32768 } ;

    uint32_t dwIndex = 0 ;

    /*  Satisfy lower bound */
    while ( dwFreq < ((dwMCk / adwDivisors[dwIndex]) / 65536) )
   80a5a:	4666      	mov	r6, ip
    {
        dwIndex++ ;
   80a5c:	463c      	mov	r4, r7
   80a5e:	e7cc      	b.n	809fa <_Z17TC_FindMckDivisormmPmS_m+0x6a>
    const uint32_t adwDivisors[5] = { 2, 8, 32, 128, dwBoardMCK / 32768 } ;

    uint32_t dwIndex = 0 ;

    /*  Satisfy lower bound */
    while ( dwFreq < ((dwMCk / adwDivisors[dwIndex]) / 65536) )
   80a60:	4676      	mov	r6, lr
    {
        dwIndex++ ;
   80a62:	2403      	movs	r4, #3
   80a64:	e7c9      	b.n	809fa <_Z17TC_FindMckDivisormmPmS_m+0x6a>
    if ( dwTcClks )
    {
        *dwTcClks = dwIndex ;
    }

    return 1 ;
   80a66:	2001      	movs	r0, #1
   80a68:	e7b8      	b.n	809dc <_Z17TC_FindMckDivisormmPmS_m+0x4c>
            return 0 ;
        }
    }

    /*  Try to maximize DIV while satisfying upper bound */
    while ( dwIndex < 4 )
   80a6a:	462e      	mov	r6, r5
   80a6c:	e7bb      	b.n	809e6 <_Z17TC_FindMckDivisormmPmS_m+0x56>
    {

        if ( dwFreq > (dwMCk / adwDivisors[dwIndex + 1]) )
   80a6e:	4646      	mov	r6, r8
   80a70:	4674      	mov	r4, lr
   80a72:	e7b8      	b.n	809e6 <_Z17TC_FindMckDivisormmPmS_m+0x56>
            return 0 ;
        }
    }

    /*  Try to maximize DIV while satisfying upper bound */
    while ( dwIndex < 4 )
   80a74:	462e      	mov	r6, r5
   80a76:	4674      	mov	r4, lr
   80a78:	e7b5      	b.n	809e6 <_Z17TC_FindMckDivisormmPmS_m+0x56>
    {

        if ( dwFreq > (dwMCk / adwDivisors[dwIndex + 1]) )
   80a7a:	4666      	mov	r6, ip
   80a7c:	463c      	mov	r4, r7
   80a7e:	e7b2      	b.n	809e6 <_Z17TC_FindMckDivisormmPmS_m+0x56>
            return 0 ;
        }
    }

    /*  Try to maximize DIV while satisfying upper bound */
    while ( dwIndex < 4 )
   80a80:	462e      	mov	r6, r5
   80a82:	463c      	mov	r4, r7
   80a84:	e7af      	b.n	809e6 <_Z17TC_FindMckDivisormmPmS_m+0x56>
   80a86:	bf00      	nop

00080a88 <_Z12TC_GetStatusP2Tcm>:
 */
uint32_t TC_GetStatus(Tc *p_tc, uint32_t ul_channel)
{
	TcChannel *tc_channel;

	tc_channel = p_tc->TC_CHANNEL + ul_channel;
   80a88:	eb00 1181 	add.w	r1, r0, r1, lsl #6
	return tc_channel->TC_SR;
   80a8c:	6a08      	ldr	r0, [r1, #32]
}
   80a8e:	4770      	bx	lr

00080a90 <_Z8TC_SetRCP2Tcmm>:
 * \param tc Pointer to a TC instance.
 * \param chan Channel to configure.
 * \param v New value for RC.
 */
void TC_SetRC(Tc *tc, uint32_t chan, uint32_t v) {
	tc->TC_CHANNEL[chan].TC_RC = v;
   80a90:	eb00 1181 	add.w	r1, r0, r1, lsl #6
   80a94:	61ca      	str	r2, [r1, #28]
   80a96:	4770      	bx	lr

00080a98 <_ZN15SystemTickClassC1Emm>:
/************************************************************************/
/* SYSTEM TICK CLASS FUNCTIONS                                          */
/************************************************************************/

//Constructor to configure basic instance information
SystemTickClass::SystemTickClass(uint32_t channel, uint32_t frequency){
   80a98:	b530      	push	{r4, r5, lr}
   80a9a:	4604      	mov	r4, r0
   80a9c:	b083      	sub	sp, #12
	switch (channel)
   80a9e:	2908      	cmp	r1, #8
   80aa0:	f200 80bd 	bhi.w	80c1e <_ZN15SystemTickClassC1Emm+0x186>
   80aa4:	e8df f001 	tbb	[pc, r1]
   80aa8:	7c74a46c 	.word	0x7c74a46c
   80aac:	9c948c84 	.word	0x9c948c84
   80ab0:	05          	.byte	0x05
   80ab1:	00          	.byte	0x00
		instanceID = TC2;
		break;
	
	case 8:
		channelNum = 2;
		periphID = ID_TC8;
   80ab2:	2323      	movs	r3, #35	; 0x23
		IRQnID = TC8_IRQn;
		instanceID = TC2;
		break;	
   80ab4:	4618      	mov	r0, r3
	
	case 8:
		channelNum = 2;
		periphID = ID_TC8;
		IRQnID = TC8_IRQn;
		instanceID = TC2;
   80ab6:	4d5b      	ldr	r5, [pc, #364]	; (80c24 <_ZN15SystemTickClassC1Emm+0x18c>)
		IRQnID = TC7_IRQn;
		instanceID = TC2;
		break;
	
	case 8:
		channelNum = 2;
   80ab8:	2102      	movs	r1, #2
		periphID = ID_TC8;
   80aba:	60e3      	str	r3, [r4, #12]
		IRQnID = TC8_IRQn;
   80abc:	7123      	strb	r3, [r4, #4]
		instanceID = TC2;
   80abe:	60a5      	str	r5, [r4, #8]
		IRQnID = TC7_IRQn;
		instanceID = TC2;
		break;
	
	case 8:
		channelNum = 2;
   80ac0:	6121      	str	r1, [r4, #16]
	default:
		break;
	}
	
	channelFreq = frequency;
	tickTock = 0;
   80ac2:	2300      	movs	r3, #0
		break;	
	default:
		break;
	}
	
	channelFreq = frequency;
   80ac4:	6162      	str	r2, [r4, #20]
	tickTock = 0;
   80ac6:	6023      	str	r3, [r4, #0]
};

//Initialize the timer with given period and units
void SystemTickClass::initializeTick(){
	//Enable peripheral clock
	pmc_enable_periph_clk(periphID);
   80ac8:	4b57      	ldr	r3, [pc, #348]	; (80c28 <_ZN15SystemTickClassC1Emm+0x190>)
   80aca:	4798      	blx	r3
	
	//Enable interrupts
	NVIC_DisableIRQ(IRQnID);
   80acc:	f994 2004 	ldrsb.w	r2, [r4, #4]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
   80ad0:	2101      	movs	r1, #1
   80ad2:	0953      	lsrs	r3, r2, #5
   80ad4:	009b      	lsls	r3, r3, #2
   80ad6:	b2d0      	uxtb	r0, r2
   80ad8:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
   80adc:	f000 051f 	and.w	r5, r0, #31
   80ae0:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
   80ae4:	40a9      	lsls	r1, r5
    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
   80ae6:	2a00      	cmp	r2, #0

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
   80ae8:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
   80aec:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
   80af0:	f2c0 8086 	blt.w	80c00 <_ZN15SystemTickClassC1Emm+0x168>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
   80af4:	f102 4260 	add.w	r2, r2, #3758096384	; 0xe0000000
   80af8:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
   80afc:	2330      	movs	r3, #48	; 0x30
   80afe:	f882 3300 	strb.w	r3, [r2, #768]	; 0x300
	NVIC_ClearPendingIRQ(IRQnID);
	NVIC_SetPriority(IRQnID, (uint32_t)PRIOR_TIMER);
	NVIC_EnableIRQ(IRQnID);
   80b02:	f994 3004 	ldrsb.w	r3, [r4, #4]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
   80b06:	4949      	ldr	r1, [pc, #292]	; (80c2c <_ZN15SystemTickClassC1Emm+0x194>)
   80b08:	f003 001f 	and.w	r0, r3, #31
   80b0c:	2201      	movs	r2, #1
   80b0e:	4082      	lsls	r2, r0
   80b10:	095b      	lsrs	r3, r3, #5
   80b12:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	
	//Find the best clock divider for given frequency
	TC_FindMckDivisor(channelFreq, MASTER_CLOCK, divisor, tcClocks, MASTER_CLOCK);
   80b16:	f101 5114 	add.w	r1, r1, #620756992	; 0x25000000
   80b1a:	f501 415c 	add.w	r1, r1, #56320	; 0xdc00
   80b1e:	f104 0014 	add.w	r0, r4, #20
   80b22:	c80d      	ldmia	r0, {r0, r2, r3}
   80b24:	4d42      	ldr	r5, [pc, #264]	; (80c30 <_ZN15SystemTickClassC1Emm+0x198>)
   80b26:	9100      	str	r1, [sp, #0]
   80b28:	47a8      	blx	r5
	
	uint32_t clockVal, divider;
	switch ((uint32_t)*divisor)
   80b2a:	69a3      	ldr	r3, [r4, #24]
   80b2c:	681a      	ldr	r2, [r3, #0]
   80b2e:	2a20      	cmp	r2, #32
   80b30:	d06d      	beq.n	80c0e <_ZN15SystemTickClassC1Emm+0x176>
   80b32:	2a80      	cmp	r2, #128	; 0x80
   80b34:	d06f      	beq.n	80c16 <_ZN15SystemTickClassC1Emm+0x17e>
   80b36:	f24c 0301 	movw	r3, #49153	; 0xc001
   80b3a:	2a08      	cmp	r2, #8
   80b3c:	bf0b      	itete	eq
   80b3e:	461a      	moveq	r2, r3
   80b40:	f44f 4240 	movne.w	r2, #49152	; 0xc000
   80b44:	2508      	moveq	r5, #8
   80b46:	2502      	movne	r5, #2
	}
	
	
	//Set counter mode and behavior
	uint32_t chMode = (clockVal | TC_CMR_WAVE | TC_CMR_WAVSEL_UP_RC);
	TC_Configure(instanceID, channelNum, chMode);
   80b48:	6921      	ldr	r1, [r4, #16]
   80b4a:	68a0      	ldr	r0, [r4, #8]
   80b4c:	4b39      	ldr	r3, [pc, #228]	; (80c34 <_ZN15SystemTickClassC1Emm+0x19c>)
   80b4e:	4798      	blx	r3
	
	//Set counter value
	uint32_t countMax = MASTER_CLOCK / divider / channelFreq;
	TC_SetRC(instanceID, channelNum, countMax);
   80b50:	4a39      	ldr	r2, [pc, #228]	; (80c38 <_ZN15SystemTickClassC1Emm+0x1a0>)
   80b52:	6963      	ldr	r3, [r4, #20]
   80b54:	fbb2 f2f5 	udiv	r2, r2, r5
   80b58:	6921      	ldr	r1, [r4, #16]
   80b5a:	fbb2 f2f3 	udiv	r2, r2, r3
   80b5e:	68a0      	ldr	r0, [r4, #8]
   80b60:	4b36      	ldr	r3, [pc, #216]	; (80c3c <_ZN15SystemTickClassC1Emm+0x1a4>)
   80b62:	4798      	blx	r3

	//Set interrupts
	instanceID->TC_CHANNEL[channelNum].TC_IER = TC_IER_CPCS;
   80b64:	68a0      	ldr	r0, [r4, #8]
   80b66:	6921      	ldr	r1, [r4, #16]
   80b68:	2210      	movs	r2, #16
   80b6a:	eb00 1381 	add.w	r3, r0, r1, lsl #6
	instanceID->TC_CHANNEL[channelNum].TC_IDR = ~TC_IER_CPCS;	
   80b6e:	f06f 0510 	mvn.w	r5, #16
	//Set counter value
	uint32_t countMax = MASTER_CLOCK / divider / channelFreq;
	TC_SetRC(instanceID, channelNum, countMax);

	//Set interrupts
	instanceID->TC_CHANNEL[channelNum].TC_IER = TC_IER_CPCS;
   80b72:	625a      	str	r2, [r3, #36]	; 0x24
	instanceID->TC_CHANNEL[channelNum].TC_IDR = ~TC_IER_CPCS;	
}

//Start timer from last location
void SystemTickClass::start(){
	TC_Start(instanceID, channelNum);
   80b74:	4a32      	ldr	r2, [pc, #200]	; (80c40 <_ZN15SystemTickClassC1Emm+0x1a8>)
	uint32_t countMax = MASTER_CLOCK / divider / channelFreq;
	TC_SetRC(instanceID, channelNum, countMax);

	//Set interrupts
	instanceID->TC_CHANNEL[channelNum].TC_IER = TC_IER_CPCS;
	instanceID->TC_CHANNEL[channelNum].TC_IDR = ~TC_IER_CPCS;	
   80b76:	629d      	str	r5, [r3, #40]	; 0x28
}

//Start timer from last location
void SystemTickClass::start(){
	TC_Start(instanceID, channelNum);
   80b78:	4790      	blx	r2
	tickTock = 0;
	
	//Initialize and start the timer
	this->initializeTick();
	this->start();
}
   80b7a:	4620      	mov	r0, r4
   80b7c:	b003      	add	sp, #12
   80b7e:	bd30      	pop	{r4, r5, pc}
	/* Timer Counter 0 */
	case 0:
		channelNum = 0;
		periphID = ID_TC0;
		IRQnID = TC0_IRQn;
		instanceID = TC0;
   80b80:	4930      	ldr	r1, [pc, #192]	; (80c44 <_ZN15SystemTickClassC1Emm+0x1ac>)
	switch (channel)
	{
	/* Timer Counter 0 */
	case 0:
		channelNum = 0;
		periphID = ID_TC0;
   80b82:	201b      	movs	r0, #27
SystemTickClass::SystemTickClass(uint32_t channel, uint32_t frequency){
	switch (channel)
	{
	/* Timer Counter 0 */
	case 0:
		channelNum = 0;
   80b84:	2300      	movs	r3, #0
		periphID = ID_TC0;
		IRQnID = TC0_IRQn;
		instanceID = TC0;
   80b86:	60a1      	str	r1, [r4, #8]
SystemTickClass::SystemTickClass(uint32_t channel, uint32_t frequency){
	switch (channel)
	{
	/* Timer Counter 0 */
	case 0:
		channelNum = 0;
   80b88:	6123      	str	r3, [r4, #16]
		periphID = ID_TC0;
   80b8a:	60e0      	str	r0, [r4, #12]
		IRQnID = TC0_IRQn;
   80b8c:	7120      	strb	r0, [r4, #4]
		instanceID = TC0;
		break;
   80b8e:	e798      	b.n	80ac2 <_ZN15SystemTickClassC1Emm+0x2a>
	
	case 2:
		channelNum = 2;
		periphID = ID_TC2;
		IRQnID = TC2_IRQn;
		instanceID = TC0;
   80b90:	492c      	ldr	r1, [pc, #176]	; (80c44 <_ZN15SystemTickClassC1Emm+0x1ac>)
		instanceID = TC0;
		break;
	
	case 2:
		channelNum = 2;
		periphID = ID_TC2;
   80b92:	201d      	movs	r0, #29
		IRQnID = TC1_IRQn;
		instanceID = TC0;
		break;
	
	case 2:
		channelNum = 2;
   80b94:	2302      	movs	r3, #2
		periphID = ID_TC2;
		IRQnID = TC2_IRQn;
		instanceID = TC0;
   80b96:	60a1      	str	r1, [r4, #8]
		IRQnID = TC1_IRQn;
		instanceID = TC0;
		break;
	
	case 2:
		channelNum = 2;
   80b98:	6123      	str	r3, [r4, #16]
		periphID = ID_TC2;
   80b9a:	60e0      	str	r0, [r4, #12]
		IRQnID = TC2_IRQn;
   80b9c:	7120      	strb	r0, [r4, #4]
		instanceID = TC0;
		break;
   80b9e:	e790      	b.n	80ac2 <_ZN15SystemTickClassC1Emm+0x2a>
	/* Timer Counter 1 */
	case 3:
		channelNum = 0;
		periphID = ID_TC3;
		IRQnID = TC3_IRQn;
		instanceID = TC1;
   80ba0:	4929      	ldr	r1, [pc, #164]	; (80c48 <_ZN15SystemTickClassC1Emm+0x1b0>)
		break;
		
	/* Timer Counter 1 */
	case 3:
		channelNum = 0;
		periphID = ID_TC3;
   80ba2:	201e      	movs	r0, #30
		instanceID = TC0;
		break;
		
	/* Timer Counter 1 */
	case 3:
		channelNum = 0;
   80ba4:	2300      	movs	r3, #0
		periphID = ID_TC3;
		IRQnID = TC3_IRQn;
		instanceID = TC1;
   80ba6:	60a1      	str	r1, [r4, #8]
		instanceID = TC0;
		break;
		
	/* Timer Counter 1 */
	case 3:
		channelNum = 0;
   80ba8:	6123      	str	r3, [r4, #16]
		periphID = ID_TC3;
   80baa:	60e0      	str	r0, [r4, #12]
		IRQnID = TC3_IRQn;
   80bac:	7120      	strb	r0, [r4, #4]
		instanceID = TC1;
		break;
   80bae:	e788      	b.n	80ac2 <_ZN15SystemTickClassC1Emm+0x2a>
	
	case 4:
		channelNum = 1;
		periphID = ID_TC4;
		IRQnID = TC4_IRQn;
		instanceID = TC1;
   80bb0:	4925      	ldr	r1, [pc, #148]	; (80c48 <_ZN15SystemTickClassC1Emm+0x1b0>)
		instanceID = TC1;
		break;
	
	case 4:
		channelNum = 1;
		periphID = ID_TC4;
   80bb2:	201f      	movs	r0, #31
		IRQnID = TC3_IRQn;
		instanceID = TC1;
		break;
	
	case 4:
		channelNum = 1;
   80bb4:	2301      	movs	r3, #1
		periphID = ID_TC4;
		IRQnID = TC4_IRQn;
		instanceID = TC1;
   80bb6:	60a1      	str	r1, [r4, #8]
		IRQnID = TC3_IRQn;
		instanceID = TC1;
		break;
	
	case 4:
		channelNum = 1;
   80bb8:	6123      	str	r3, [r4, #16]
		periphID = ID_TC4;
   80bba:	60e0      	str	r0, [r4, #12]
		IRQnID = TC4_IRQn;
   80bbc:	7120      	strb	r0, [r4, #4]
		instanceID = TC1;
		break;
   80bbe:	e780      	b.n	80ac2 <_ZN15SystemTickClassC1Emm+0x2a>
	
	case 5:
		channelNum = 2;
		periphID = ID_TC5;
		IRQnID = TC5_IRQn;
		instanceID = TC1;
   80bc0:	4921      	ldr	r1, [pc, #132]	; (80c48 <_ZN15SystemTickClassC1Emm+0x1b0>)
		instanceID = TC1;
		break;
	
	case 5:
		channelNum = 2;
		periphID = ID_TC5;
   80bc2:	2020      	movs	r0, #32
		IRQnID = TC4_IRQn;
		instanceID = TC1;
		break;
	
	case 5:
		channelNum = 2;
   80bc4:	2302      	movs	r3, #2
		periphID = ID_TC5;
		IRQnID = TC5_IRQn;
		instanceID = TC1;
   80bc6:	60a1      	str	r1, [r4, #8]
		IRQnID = TC4_IRQn;
		instanceID = TC1;
		break;
	
	case 5:
		channelNum = 2;
   80bc8:	6123      	str	r3, [r4, #16]
		periphID = ID_TC5;
   80bca:	60e0      	str	r0, [r4, #12]
		IRQnID = TC5_IRQn;
   80bcc:	7120      	strb	r0, [r4, #4]
		instanceID = TC1;
		break;
   80bce:	e778      	b.n	80ac2 <_ZN15SystemTickClassC1Emm+0x2a>
	/* Timer Counter 2 */
	case 6:
		channelNum = 0;
		periphID = ID_TC6;
		IRQnID = TC6_IRQn;
		instanceID = TC2;
   80bd0:	4914      	ldr	r1, [pc, #80]	; (80c24 <_ZN15SystemTickClassC1Emm+0x18c>)
		break;
	
	/* Timer Counter 2 */
	case 6:
		channelNum = 0;
		periphID = ID_TC6;
   80bd2:	2021      	movs	r0, #33	; 0x21
		instanceID = TC1;
		break;
	
	/* Timer Counter 2 */
	case 6:
		channelNum = 0;
   80bd4:	2300      	movs	r3, #0
		periphID = ID_TC6;
		IRQnID = TC6_IRQn;
		instanceID = TC2;
   80bd6:	60a1      	str	r1, [r4, #8]
		instanceID = TC1;
		break;
	
	/* Timer Counter 2 */
	case 6:
		channelNum = 0;
   80bd8:	6123      	str	r3, [r4, #16]
		periphID = ID_TC6;
   80bda:	60e0      	str	r0, [r4, #12]
		IRQnID = TC6_IRQn;
   80bdc:	7120      	strb	r0, [r4, #4]
		instanceID = TC2;
		break;
   80bde:	e770      	b.n	80ac2 <_ZN15SystemTickClassC1Emm+0x2a>
	
	case 7:
		channelNum = 1;
		periphID = ID_TC7;
		IRQnID = TC7_IRQn;
		instanceID = TC2;
   80be0:	4910      	ldr	r1, [pc, #64]	; (80c24 <_ZN15SystemTickClassC1Emm+0x18c>)
		instanceID = TC2;
		break;
	
	case 7:
		channelNum = 1;
		periphID = ID_TC7;
   80be2:	2022      	movs	r0, #34	; 0x22
		IRQnID = TC6_IRQn;
		instanceID = TC2;
		break;
	
	case 7:
		channelNum = 1;
   80be4:	2301      	movs	r3, #1
		periphID = ID_TC7;
		IRQnID = TC7_IRQn;
		instanceID = TC2;
   80be6:	60a1      	str	r1, [r4, #8]
		IRQnID = TC6_IRQn;
		instanceID = TC2;
		break;
	
	case 7:
		channelNum = 1;
   80be8:	6123      	str	r3, [r4, #16]
		periphID = ID_TC7;
   80bea:	60e0      	str	r0, [r4, #12]
		IRQnID = TC7_IRQn;
   80bec:	7120      	strb	r0, [r4, #4]
		instanceID = TC2;
		break;
   80bee:	e768      	b.n	80ac2 <_ZN15SystemTickClassC1Emm+0x2a>
		
	case 1:
		channelNum = 1;
		periphID = ID_TC1;
		IRQnID = TC1_IRQn;
		instanceID = TC0;
   80bf0:	4914      	ldr	r1, [pc, #80]	; (80c44 <_ZN15SystemTickClassC1Emm+0x1ac>)
		instanceID = TC0;
		break;
		
	case 1:
		channelNum = 1;
		periphID = ID_TC1;
   80bf2:	201c      	movs	r0, #28
		IRQnID = TC0_IRQn;
		instanceID = TC0;
		break;
		
	case 1:
		channelNum = 1;
   80bf4:	2301      	movs	r3, #1
		periphID = ID_TC1;
		IRQnID = TC1_IRQn;
		instanceID = TC0;
   80bf6:	60a1      	str	r1, [r4, #8]
		IRQnID = TC0_IRQn;
		instanceID = TC0;
		break;
		
	case 1:
		channelNum = 1;
   80bf8:	6123      	str	r3, [r4, #16]
		periphID = ID_TC1;
   80bfa:	60e0      	str	r0, [r4, #12]
		IRQnID = TC1_IRQn;
   80bfc:	7120      	strb	r0, [r4, #4]
		instanceID = TC0;
		break;
   80bfe:	e760      	b.n	80ac2 <_ZN15SystemTickClassC1Emm+0x2a>
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
   80c00:	4b12      	ldr	r3, [pc, #72]	; (80c4c <_ZN15SystemTickClassC1Emm+0x1b4>)
   80c02:	f000 000f 	and.w	r0, r0, #15
   80c06:	4403      	add	r3, r0
   80c08:	2230      	movs	r2, #48	; 0x30
   80c0a:	761a      	strb	r2, [r3, #24]
   80c0c:	e779      	b.n	80b02 <_ZN15SystemTickClassC1Emm+0x6a>
		divider = 8;
		break;
	
	case 32:
		clockVal = TC_CMR_TCCLKS_TIMER_CLOCK3;
		divider = 32;
   80c0e:	4615      	mov	r5, r2
   80c10:	f24c 0202 	movw	r2, #49154	; 0xc002
   80c14:	e798      	b.n	80b48 <_ZN15SystemTickClassC1Emm+0xb0>
		break;
	
	case 128:
		clockVal = TC_CMR_TCCLKS_TIMER_CLOCK4;
		divider = 128;
   80c16:	4615      	mov	r5, r2
   80c18:	f24c 0203 	movw	r2, #49155	; 0xc003
   80c1c:	e794      	b.n	80b48 <_ZN15SystemTickClassC1Emm+0xb0>
   80c1e:	68c0      	ldr	r0, [r0, #12]
   80c20:	e74f      	b.n	80ac2 <_ZN15SystemTickClassC1Emm+0x2a>
   80c22:	bf00      	nop
   80c24:	40088000 	.word	0x40088000
   80c28:	00080679 	.word	0x00080679
   80c2c:	e000e100 	.word	0xe000e100
   80c30:	00080991 	.word	0x00080991
   80c34:	00080971 	.word	0x00080971
   80c38:	0501bd00 	.word	0x0501bd00
   80c3c:	00080a91 	.word	0x00080a91
   80c40:	00080989 	.word	0x00080989
   80c44:	40080000 	.word	0x40080000
   80c48:	40084000 	.word	0x40084000
   80c4c:	e000ecfc 	.word	0xe000ecfc

00080c50 <_ZN15SystemTickClass10IRQHandlerEv>:
	this->initializeTick();
	this->start();
}

//Interrupt call function
void SystemTickClass::IRQHandler(){
   80c50:	b510      	push	{r4, lr}
   80c52:	4604      	mov	r4, r0
	//Read the status register so the next interrupt can occur
	TC_GetStatus(instanceID, channelNum);
   80c54:	4b06      	ldr	r3, [pc, #24]	; (80c70 <_ZN15SystemTickClass10IRQHandlerEv+0x20>)
   80c56:	6901      	ldr	r1, [r0, #16]
   80c58:	6880      	ldr	r0, [r0, #8]
   80c5a:	4798      	blx	r3
	
	//Increase the internal counter
	++tickTock;
   80c5c:	6823      	ldr	r3, [r4, #0]
	
	//If attached interrupt function exists, call it
	if(onInterruptCallback)
   80c5e:	6a22      	ldr	r2, [r4, #32]
void SystemTickClass::IRQHandler(){
	//Read the status register so the next interrupt can occur
	TC_GetStatus(instanceID, channelNum);
	
	//Increase the internal counter
	++tickTock;
   80c60:	3301      	adds	r3, #1
   80c62:	6023      	str	r3, [r4, #0]
	
	//If attached interrupt function exists, call it
	if(onInterruptCallback)
   80c64:	b112      	cbz	r2, 80c6c <_ZN15SystemTickClass10IRQHandlerEv+0x1c>
		onInterruptCallback();
};
   80c66:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	//Increase the internal counter
	++tickTock;
	
	//If attached interrupt function exists, call it
	if(onInterruptCallback)
		onInterruptCallback();
   80c6a:	4710      	bx	r2
   80c6c:	bd10      	pop	{r4, pc}
   80c6e:	bf00      	nop
   80c70:	00080a89 	.word	0x00080a89

00080c74 <_Z17delayMillisecondsm>:

extern void delaySeconds(uint32_t S){
	//Nothing yet
}

extern void delayMilliseconds(uint32_t mS){
   80c74:	b430      	push	{r4, r5}
}

//Returns current value of tickTock
uint32_t SystemTickClass::tickCount(){
	//Disable channel interrupt
	instanceID->TC_CHANNEL[channelNum].TC_IDR |= TC_IER_CPCS;
   80c76:	4c0e      	ldr	r4, [pc, #56]	; (80cb0 <_Z17delayMillisecondsm+0x3c>)
   80c78:	68a3      	ldr	r3, [r4, #8]
   80c7a:	6922      	ldr	r2, [r4, #16]
   80c7c:	eb03 1282 	add.w	r2, r3, r2, lsl #6
   80c80:	4613      	mov	r3, r2
   80c82:	6a91      	ldr	r1, [r2, #40]	; 0x28
   80c84:	f041 0110 	orr.w	r1, r1, #16
   80c88:	6291      	str	r1, [r2, #40]	; 0x28
	
	//Copy the current tick value
	uint32_t tempTick = tickTock;
   80c8a:	6825      	ldr	r5, [r4, #0]
	
	//Re-enable channel interrupt
	instanceID->TC_CHANNEL[channelNum].TC_IER |= TC_IER_CPCS;
   80c8c:	6a51      	ldr	r1, [r2, #36]	; 0x24
   80c8e:	f041 0110 	orr.w	r1, r1, #16
   80c92:	6251      	str	r1, [r2, #36]	; 0x24
}

//Returns current value of tickTock
uint32_t SystemTickClass::tickCount(){
	//Disable channel interrupt
	instanceID->TC_CHANNEL[channelNum].TC_IDR |= TC_IER_CPCS;
   80c94:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   80c96:	f042 0210 	orr.w	r2, r2, #16
   80c9a:	629a      	str	r2, [r3, #40]	; 0x28
	
	//Copy the current tick value
	uint32_t tempTick = tickTock;
   80c9c:	6822      	ldr	r2, [r4, #0]
	
	//Re-enable channel interrupt
	instanceID->TC_CHANNEL[channelNum].TC_IER |= TC_IER_CPCS;
   80c9e:	6a59      	ldr	r1, [r3, #36]	; 0x24
	//Nothing yet
}

extern void delayMilliseconds(uint32_t mS){
	uint32_t currentTime = millis();
	while(millis()-currentTime < mS); //Wait for time to expire
   80ca0:	1b52      	subs	r2, r2, r5
	
	//Copy the current tick value
	uint32_t tempTick = tickTock;
	
	//Re-enable channel interrupt
	instanceID->TC_CHANNEL[channelNum].TC_IER |= TC_IER_CPCS;
   80ca2:	f041 0110 	orr.w	r1, r1, #16
	//Nothing yet
}

extern void delayMilliseconds(uint32_t mS){
	uint32_t currentTime = millis();
	while(millis()-currentTime < mS); //Wait for time to expire
   80ca6:	4282      	cmp	r2, r0
	
	//Copy the current tick value
	uint32_t tempTick = tickTock;
	
	//Re-enable channel interrupt
	instanceID->TC_CHANNEL[channelNum].TC_IER |= TC_IER_CPCS;
   80ca8:	6259      	str	r1, [r3, #36]	; 0x24
	//Nothing yet
}

extern void delayMilliseconds(uint32_t mS){
	uint32_t currentTime = millis();
	while(millis()-currentTime < mS); //Wait for time to expire
   80caa:	d3f3      	bcc.n	80c94 <_Z17delayMillisecondsm+0x20>
}
   80cac:	bc30      	pop	{r4, r5}
   80cae:	4770      	bx	lr
   80cb0:	200007f0 	.word	0x200007f0

00080cb4 <_Z6millisv>:
}

//Returns current value of tickTock
uint32_t SystemTickClass::tickCount(){
	//Disable channel interrupt
	instanceID->TC_CHANNEL[channelNum].TC_IDR |= TC_IER_CPCS;
   80cb4:	4a07      	ldr	r2, [pc, #28]	; (80cd4 <_Z6millisv+0x20>)
   80cb6:	6911      	ldr	r1, [r2, #16]
   80cb8:	6893      	ldr	r3, [r2, #8]
   80cba:	eb03 1381 	add.w	r3, r3, r1, lsl #6
   80cbe:	6a99      	ldr	r1, [r3, #40]	; 0x28
   80cc0:	f041 0110 	orr.w	r1, r1, #16
   80cc4:	6299      	str	r1, [r3, #40]	; 0x28
	
	//Copy the current tick value
	uint32_t tempTick = tickTock;
   80cc6:	6810      	ldr	r0, [r2, #0]
	
	//Re-enable channel interrupt
	instanceID->TC_CHANNEL[channelNum].TC_IER |= TC_IER_CPCS;
   80cc8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   80cca:	f042 0210 	orr.w	r2, r2, #16
   80cce:	625a      	str	r2, [r3, #36]	; 0x24

/* Returns number of milliseconds elapsed since program start.
   1 Millisecond Resolution*/
extern uint32_t millis(){
	return milliSysTick.tickCount();
}
   80cd0:	4770      	bx	lr
   80cd2:	bf00      	nop
   80cd4:	200007f0 	.word	0x200007f0

00080cd8 <_ZN12TwoWireClassC1EP3Twi>:
/************************************************************************/
/* Class Definition                                                     */
/************************************************************************/

/** Constructor*/
TwoWireClass::TwoWireClass(Twi *pTwi){
   80cd8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   80cdc:	4604      	mov	r4, r0
   80cde:	460f      	mov	r7, r1
   80ce0:	b082      	sub	sp, #8
   80ce2:	4b46      	ldr	r3, [pc, #280]	; (80dfc <_ZN12TwoWireClassC1EP3Twi+0x124>)
   80ce4:	4e46      	ldr	r6, [pc, #280]	; (80e00 <_ZN12TwoWireClassC1EP3Twi+0x128>)
   80ce6:	4798      	blx	r3
   80ce8:	f104 0a74 	add.w	sl, r4, #116	; 0x74
   80cec:	2300      	movs	r3, #0
   80cee:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
   80cf2:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
   80cf6:	4d43      	ldr	r5, [pc, #268]	; (80e04 <_ZN12TwoWireClassC1EP3Twi+0x12c>)
   80cf8:	f104 0134 	add.w	r1, r4, #52	; 0x34
   80cfc:	2210      	movs	r2, #16
   80cfe:	f104 09c8 	add.w	r9, r4, #200	; 0xc8
   80d02:	4650      	mov	r0, sl
   80d04:	6326      	str	r6, [r4, #48]	; 0x30
   80d06:	47a8      	blx	r5
   80d08:	f504 788e 	add.w	r8, r4, #284	; 0x11c
   80d0c:	f104 0188 	add.w	r1, r4, #136	; 0x88
   80d10:	2210      	movs	r2, #16
   80d12:	4648      	mov	r0, r9
   80d14:	47a8      	blx	r5
   80d16:	f104 01dc 	add.w	r1, r4, #220	; 0xdc
   80d1a:	2210      	movs	r2, #16
   80d1c:	4640      	mov	r0, r8
   80d1e:	47a8      	blx	r5
	//Clear buffers
	txBuffer.flush();
   80d20:	4d39      	ldr	r5, [pc, #228]	; (80e08 <_ZN12TwoWireClassC1EP3Twi+0x130>)
   80d22:	4650      	mov	r0, sl
   80d24:	47a8      	blx	r5
	rxBuffer.flush();
   80d26:	4648      	mov	r0, r9
   80d28:	47a8      	blx	r5
	svBuffer.flush();
   80d2a:	4640      	mov	r0, r8
   80d2c:	47a8      	blx	r5
	
	//Save pin numbers
	if(pTwi == TWI1){ //Wire
   80d2e:	4b37      	ldr	r3, [pc, #220]	; (80e0c <_ZN12TwoWireClassC1EP3Twi+0x134>)
   80d30:	429f      	cmp	r7, r3
   80d32:	d056      	beq.n	80de2 <_ZN12TwoWireClassC1EP3Twi+0x10a>
		pmc_enable_periph_clk(ID_PIOB);
	} else {		 //Wire1
		SDA = 70u;
		SCL = 71u;
		twi = pTwi;
		periphID = ID_TWI0;
   80d34:	2316      	movs	r3, #22
		twiClock = 400000;
		
		//Ensure that peripheral clock for SDA/SCL PIO controller is on
		pmc_enable_periph_clk(ID_PIOB);
	} else {		 //Wire1
		SDA = 70u;
   80d36:	2146      	movs	r1, #70	; 0x46
		SCL = 71u;
   80d38:	2247      	movs	r2, #71	; 0x47
		twi = pTwi;
   80d3a:	61a7      	str	r7, [r4, #24]
		periphID = ID_TWI0;
		IRQnID = TWI0_IRQn;
		twiClock = 400000;
   80d3c:	6326      	str	r6, [r4, #48]	; 0x30
		twiClock = 400000;
		
		//Ensure that peripheral clock for SDA/SCL PIO controller is on
		pmc_enable_periph_clk(ID_PIOB);
	} else {		 //Wire1
		SDA = 70u;
   80d3e:	6261      	str	r1, [r4, #36]	; 0x24
		SCL = 71u;
   80d40:	62a2      	str	r2, [r4, #40]	; 0x28
		twi = pTwi;
		periphID = ID_TWI0;
   80d42:	6223      	str	r3, [r4, #32]
		IRQnID = TWI0_IRQn;
   80d44:	7723      	strb	r3, [r4, #28]
		twiClock = 400000;
		
		//Ensure that peripheral clock for SDA/SCL PIO controller is on
		pmc_enable_periph_clk(ID_PIOA);
   80d46:	200b      	movs	r0, #11
   80d48:	4f31      	ldr	r7, [pc, #196]	; (80e10 <_ZN12TwoWireClassC1EP3Twi+0x138>)
   80d4a:	47b8      	blx	r7

/** Initializes I2C hardware*/
void TwoWireClass::setupHardware(){

	PIO_configurePin(
	pinCharacteristic[SDA].port,
   80d4c:	6a63      	ldr	r3, [r4, #36]	; 0x24
	pinCharacteristic[SDA].pinMask,
	pinCharacteristic[SDA].peripheralType,
	pinCharacteristic[SDA].pinAttribute, 0x20);
   80d4e:	4e31      	ldr	r6, [pc, #196]	; (80e14 <_ZN12TwoWireClassC1EP3Twi+0x13c>)
   80d50:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
   80d54:	009b      	lsls	r3, r3, #2
   80d56:	18f1      	adds	r1, r6, r3
   80d58:	2520      	movs	r5, #32
   80d5a:	58f0      	ldr	r0, [r6, r3]
   80d5c:	7b0a      	ldrb	r2, [r1, #12]
   80d5e:	694b      	ldr	r3, [r1, #20]
   80d60:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 80e20 <_ZN12TwoWireClassC1EP3Twi+0x148>
   80d64:	6849      	ldr	r1, [r1, #4]
   80d66:	9500      	str	r5, [sp, #0]
   80d68:	47c0      	blx	r8
	
	PIO_configurePin(
	pinCharacteristic[SCL].port,
   80d6a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	pinCharacteristic[SCL].pinMask,
	pinCharacteristic[SCL].peripheralType,
	pinCharacteristic[SCL].pinAttribute, 0x20);
   80d6c:	9500      	str	r5, [sp, #0]
   80d6e:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
   80d72:	009b      	lsls	r3, r3, #2
   80d74:	18f1      	adds	r1, r6, r3
   80d76:	7b0a      	ldrb	r2, [r1, #12]
   80d78:	58f0      	ldr	r0, [r6, r3]
   80d7a:	694b      	ldr	r3, [r1, #20]
   80d7c:	6849      	ldr	r1, [r1, #4]
   80d7e:	47c0      	blx	r8
	
	//Setup the PIO pins correctly
	setupHardware();
	
	//Enable I2C peripheral clock
	pmc_enable_periph_clk(periphID);
   80d80:	6a20      	ldr	r0, [r4, #32]
   80d82:	47b8      	blx	r7
	
	//Interrupt handling
	NVIC_DisableIRQ(IRQnID);
   80d84:	f994 201c 	ldrsb.w	r2, [r4, #28]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
   80d88:	2101      	movs	r1, #1
   80d8a:	0953      	lsrs	r3, r2, #5
   80d8c:	009b      	lsls	r3, r3, #2
   80d8e:	b2d0      	uxtb	r0, r2
   80d90:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
   80d94:	f000 061f 	and.w	r6, r0, #31
   80d98:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
   80d9c:	40b1      	lsls	r1, r6
    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
   80d9e:	2a00      	cmp	r2, #0

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
   80da0:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
   80da4:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
   80da8:	db15      	blt.n	80dd6 <_ZN12TwoWireClassC1EP3Twi+0xfe>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
   80daa:	f102 4260 	add.w	r2, r2, #3758096384	; 0xe0000000
   80dae:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
   80db2:	f882 5300 	strb.w	r5, [r2, #768]	; 0x300
	NVIC_ClearPendingIRQ(IRQnID);
	NVIC_SetPriority(IRQnID, (uint32_t)PRIOR_I2C);
	NVIC_EnableIRQ(IRQnID);
   80db6:	f994 301c 	ldrsb.w	r3, [r4, #28]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
   80dba:	4817      	ldr	r0, [pc, #92]	; (80e18 <_ZN12TwoWireClassC1EP3Twi+0x140>)
   80dbc:	f003 011f 	and.w	r1, r3, #31
   80dc0:	2201      	movs	r2, #1
   80dc2:	408a      	lsls	r2, r1
   80dc4:	095b      	lsrs	r3, r3, #5
   80dc6:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
	
	TWISTATUS = UNINITIALIZED;
}
   80dca:	4620      	mov	r0, r4
	NVIC_DisableIRQ(IRQnID);
	NVIC_ClearPendingIRQ(IRQnID);
	NVIC_SetPriority(IRQnID, (uint32_t)PRIOR_I2C);
	NVIC_EnableIRQ(IRQnID);
	
	TWISTATUS = UNINITIALIZED;
   80dcc:	2100      	movs	r1, #0
   80dce:	75a1      	strb	r1, [r4, #22]
}
   80dd0:	b002      	add	sp, #8
   80dd2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
   80dd6:	4b11      	ldr	r3, [pc, #68]	; (80e1c <_ZN12TwoWireClassC1EP3Twi+0x144>)
   80dd8:	f000 000f 	and.w	r0, r0, #15
   80ddc:	4403      	add	r3, r0
   80dde:	761d      	strb	r5, [r3, #24]
   80de0:	e7e9      	b.n	80db6 <_ZN12TwoWireClassC1EP3Twi+0xde>
	//Save pin numbers
	if(pTwi == TWI1){ //Wire
		SDA = 20u;
		SCL = 21u;
		twi = pTwi;
		periphID = ID_TWI1;
   80de2:	2317      	movs	r3, #23
	rxBuffer.flush();
	svBuffer.flush();
	
	//Save pin numbers
	if(pTwi == TWI1){ //Wire
		SDA = 20u;
   80de4:	2114      	movs	r1, #20
		SCL = 21u;
   80de6:	2215      	movs	r2, #21
		twi = pTwi;
   80de8:	61a7      	str	r7, [r4, #24]
		periphID = ID_TWI1;
		IRQnID = TWI1_IRQn;
		twiClock = 400000;
   80dea:	6326      	str	r6, [r4, #48]	; 0x30
	rxBuffer.flush();
	svBuffer.flush();
	
	//Save pin numbers
	if(pTwi == TWI1){ //Wire
		SDA = 20u;
   80dec:	6261      	str	r1, [r4, #36]	; 0x24
		SCL = 21u;
   80dee:	62a2      	str	r2, [r4, #40]	; 0x28
		twi = pTwi;
		periphID = ID_TWI1;
   80df0:	6223      	str	r3, [r4, #32]
		IRQnID = TWI1_IRQn;
   80df2:	7723      	strb	r3, [r4, #28]
		twiClock = 400000;
		
		//Ensure that peripheral clock for SDA/SCL PIO controller is on
		pmc_enable_periph_clk(ID_PIOB);
   80df4:	4f06      	ldr	r7, [pc, #24]	; (80e10 <_ZN12TwoWireClassC1EP3Twi+0x138>)
   80df6:	200c      	movs	r0, #12
   80df8:	47b8      	blx	r7
   80dfa:	e7a7      	b.n	80d4c <_ZN12TwoWireClassC1EP3Twi+0x74>
   80dfc:	000806bd 	.word	0x000806bd
   80e00:	00061a80 	.word	0x00061a80
   80e04:	000806c1 	.word	0x000806c1
   80e08:	000806e5 	.word	0x000806e5
   80e0c:	40090000 	.word	0x40090000
   80e10:	00080679 	.word	0x00080679
   80e14:	000815e4 	.word	0x000815e4
   80e18:	e000e100 	.word	0xe000e100
   80e1c:	e000ecfc 	.word	0xe000ecfc
   80e20:	000805b9 	.word	0x000805b9

00080e24 <_ZN12TwoWireClass5beginEv>:
	TWISTATUS = UNINITIALIZED;
}

/** Initializes as I2C Master*/
uint32_t TwoWireClass::begin(){
	if(initialized == true)
   80e24:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
   80e28:	b10b      	cbz	r3, 80e2e <_ZN12TwoWireClass5beginEv+0xa>
		return 1u;
   80e2a:	2001      	movs	r0, #1
	TWIMESSAGE = NO_MESSAGE;
	TWIERROR = NO_ERROR;
	initialized = true;
	
	return TWI_ConfigureMaster(twi, twiClock, MASTER_CLOCK);
}
   80e2c:	4770      	bx	lr
	TWISTATUS = MASTER_IDLE;
	TWIMESSAGE = NO_MESSAGE;
	TWIERROR = NO_ERROR;
	initialized = true;
	
	return TWI_ConfigureMaster(twi, twiClock, MASTER_CLOCK);
   80e2e:	6982      	ldr	r2, [r0, #24]
	
	TWISTATUS = UNINITIALIZED;
}

/** Initializes as I2C Master*/
uint32_t TwoWireClass::begin(){
   80e30:	b5f0      	push	{r4, r5, r6, r7, lr}
	if(initialized == true)
		return 1u;
		
	TWISTATUS = MASTER_IDLE;
   80e32:	2501      	movs	r5, #1
 * \param mck  Master clock frequency.
 */
uint32_t TWI_ConfigureMaster( Twi* pTwi, uint32_t dwTwCk, uint32_t dwMCk )
{
	/* Disable TWI interrupts */
	pTwi->TWI_IDR = ~0UL;
   80e34:	f04f 34ff 	mov.w	r4, #4294967295
/** Initializes as I2C Master*/
uint32_t TwoWireClass::begin(){
	if(initialized == true)
		return 1u;
		
	TWISTATUS = MASTER_IDLE;
   80e38:	7585      	strb	r5, [r0, #22]
	TWIMESSAGE = NO_MESSAGE;
	TWIERROR = NO_ERROR;
	initialized = true;
	
	return TWI_ConfigureMaster(twi, twiClock, MASTER_CLOCK);
   80e3a:	6b01      	ldr	r1, [r0, #48]	; 0x30
uint32_t TwoWireClass::begin(){
	if(initialized == true)
		return 1u;
		
	TWISTATUS = MASTER_IDLE;
	TWIMESSAGE = NO_MESSAGE;
   80e3c:	7543      	strb	r3, [r0, #21]
	TWIERROR = NO_ERROR;
	initialized = true;
   80e3e:	f880 502c 	strb.w	r5, [r0, #44]	; 0x2c
	if(initialized == true)
		return 1u;
		
	TWISTATUS = MASTER_IDLE;
	TWIMESSAGE = NO_MESSAGE;
	TWIERROR = NO_ERROR;
   80e42:	7503      	strb	r3, [r0, #20]
 * \param mck  Master clock frequency.
 */
uint32_t TWI_ConfigureMaster( Twi* pTwi, uint32_t dwTwCk, uint32_t dwMCk )
{
	/* Disable TWI interrupts */
	pTwi->TWI_IDR = ~0UL;
   80e44:	6294      	str	r4, [r2, #40]	; 0x28
    pTwi->TWI_CR = TWI_CR_STOP;
}

void TWI_Reset(Twi *pTwi){
	/* Set SWRST bit to reset TWI peripheral */
	pTwi->TWI_CR = TWI_CR_SWRST;
   80e46:	2080      	movs	r0, #128	; 0x80
{
	/* Disable TWI interrupts */
	pTwi->TWI_IDR = ~0UL;

	/* Dummy read in status register */
	pTwi->TWI_SR;
   80e48:	6a14      	ldr	r4, [r2, #32]
    pTwi->TWI_CR = TWI_CR_STOP;
}

void TWI_Reset(Twi *pTwi){
	/* Set SWRST bit to reset TWI peripheral */
	pTwi->TWI_CR = TWI_CR_SWRST;
   80e4a:	6010      	str	r0, [r2, #0]
uint32_t TWI_SetClock( Twi *pTwi, uint32_t dwTwCk, uint32_t dwMCk )
{	
	uint32_t ckdiv = 0;
	uint32_t c_lh_div;

	if (dwTwCk > 400000) {
   80e4c:	4821      	ldr	r0, [pc, #132]	; (80ed4 <_ZN12TwoWireClass5beginEv+0xb0>)
}

void TWI_SetMaster(Twi *pTwi){
	/* Set Master Disable bit and Slave Disable bit */
	pTwi->TWI_CR = TWI_CR_MSDIS;
	pTwi->TWI_CR = TWI_CR_SVDIS;
   80e4e:	2620      	movs	r6, #32
	return 1u;
}

void TWI_SetMaster(Twi *pTwi){
	/* Set Master Disable bit and Slave Disable bit */
	pTwi->TWI_CR = TWI_CR_MSDIS;
   80e50:	2708      	movs	r7, #8
	pTwi->TWI_CR = TWI_CR_SVDIS;

	/* Set Master Enable bit */
	pTwi->TWI_CR = TWI_CR_MSEN;
   80e52:	2404      	movs	r4, #4
}

void TWI_Reset(Twi *pTwi){
	/* Set SWRST bit to reset TWI peripheral */
	pTwi->TWI_CR = TWI_CR_SWRST;
	pTwi->TWI_RHR;
   80e54:	f8d2 e030 	ldr.w	lr, [r2, #48]	; 0x30
uint32_t TWI_SetClock( Twi *pTwi, uint32_t dwTwCk, uint32_t dwMCk )
{	
	uint32_t ckdiv = 0;
	uint32_t c_lh_div;

	if (dwTwCk > 400000) {
   80e58:	4281      	cmp	r1, r0
	return 1u;
}

void TWI_SetMaster(Twi *pTwi){
	/* Set Master Disable bit and Slave Disable bit */
	pTwi->TWI_CR = TWI_CR_MSDIS;
   80e5a:	6017      	str	r7, [r2, #0]
	pTwi->TWI_CR = TWI_CR_SVDIS;
   80e5c:	6016      	str	r6, [r2, #0]

	/* Set Master Enable bit */
	pTwi->TWI_CR = TWI_CR_MSEN;
   80e5e:	6014      	str	r4, [r2, #0]
	
	//Dummy read on status register to clear TXRDY
	pTwi->TWI_SR;
   80e60:	6a16      	ldr	r6, [r2, #32]
uint32_t TWI_SetClock( Twi *pTwi, uint32_t dwTwCk, uint32_t dwMCk )
{	
	uint32_t ckdiv = 0;
	uint32_t c_lh_div;

	if (dwTwCk > 400000) {
   80e62:	d901      	bls.n	80e68 <_ZN12TwoWireClass5beginEv+0x44>
	/* Set as Master */
	TWI_SetMaster(pTwi);
	
	/* Configure clock*/
	if(TWI_SetClock(pTwi, dwTwCk, dwMCk) == 0u) 
		return 0u;
   80e64:	4618      	mov	r0, r3
	TWIMESSAGE = NO_MESSAGE;
	TWIERROR = NO_ERROR;
	initialized = true;
	
	return TWI_ConfigureMaster(twi, twiClock, MASTER_CLOCK);
}
   80e66:	bdf0      	pop	{r4, r5, r6, r7, pc}

	if (dwTwCk > 400000) {
		return 0u;
	}

	c_lh_div = dwMCk / (dwTwCk * 2) - 4;
   80e68:	481b      	ldr	r0, [pc, #108]	; (80ed8 <_ZN12TwoWireClass5beginEv+0xb4>)
   80e6a:	40a9      	lsls	r1, r5
   80e6c:	fbb0 f1f1 	udiv	r1, r0, r1
   80e70:	3904      	subs	r1, #4

	/* cldiv must fit in 8 bits, ckdiv must fit in 3 bits */
	while ((c_lh_div > 0xFF) && (ckdiv < 7)) {
   80e72:	29ff      	cmp	r1, #255	; 0xff
   80e74:	d918      	bls.n	80ea8 <_ZN12TwoWireClass5beginEv+0x84>
		/* Increase clock divider */
		ckdiv++;
		/* Divide cldiv value */
		c_lh_div /= 2;
   80e76:	40e9      	lsrs	r1, r5
	}

	c_lh_div = dwMCk / (dwTwCk * 2) - 4;

	/* cldiv must fit in 8 bits, ckdiv must fit in 3 bits */
	while ((c_lh_div > 0xFF) && (ckdiv < 7)) {
   80e78:	29ff      	cmp	r1, #255	; 0xff
   80e7a:	d920      	bls.n	80ebe <_ZN12TwoWireClass5beginEv+0x9a>
		/* Increase clock divider */
		ckdiv++;
		/* Divide cldiv value */
		c_lh_div /= 2;
   80e7c:	40e9      	lsrs	r1, r5
	}

	c_lh_div = dwMCk / (dwTwCk * 2) - 4;

	/* cldiv must fit in 8 bits, ckdiv must fit in 3 bits */
	while ((c_lh_div > 0xFF) && (ckdiv < 7)) {
   80e7e:	29ff      	cmp	r1, #255	; 0xff
   80e80:	d91f      	bls.n	80ec2 <_ZN12TwoWireClass5beginEv+0x9e>
		/* Increase clock divider */
		ckdiv++;
		/* Divide cldiv value */
		c_lh_div /= 2;
   80e82:	40e9      	lsrs	r1, r5
	}

	c_lh_div = dwMCk / (dwTwCk * 2) - 4;

	/* cldiv must fit in 8 bits, ckdiv must fit in 3 bits */
	while ((c_lh_div > 0xFF) && (ckdiv < 7)) {
   80e84:	29ff      	cmp	r1, #255	; 0xff
   80e86:	d91e      	bls.n	80ec6 <_ZN12TwoWireClass5beginEv+0xa2>
		/* Increase clock divider */
		ckdiv++;
		/* Divide cldiv value */
		c_lh_div /= 2;
   80e88:	40e9      	lsrs	r1, r5
	}

	c_lh_div = dwMCk / (dwTwCk * 2) - 4;

	/* cldiv must fit in 8 bits, ckdiv must fit in 3 bits */
	while ((c_lh_div > 0xFF) && (ckdiv < 7)) {
   80e8a:	29ff      	cmp	r1, #255	; 0xff
   80e8c:	d91d      	bls.n	80eca <_ZN12TwoWireClass5beginEv+0xa6>
		/* Increase clock divider */
		ckdiv++;
		/* Divide cldiv value */
		c_lh_div /= 2;
   80e8e:	40e9      	lsrs	r1, r5
	}

	c_lh_div = dwMCk / (dwTwCk * 2) - 4;

	/* cldiv must fit in 8 bits, ckdiv must fit in 3 bits */
	while ((c_lh_div > 0xFF) && (ckdiv < 7)) {
   80e90:	29ff      	cmp	r1, #255	; 0xff
   80e92:	d91c      	bls.n	80ece <_ZN12TwoWireClass5beginEv+0xaa>
		/* Increase clock divider */
		ckdiv++;
		/* Divide cldiv value */
		c_lh_div /= 2;
   80e94:	40e9      	lsrs	r1, r5
	}

	c_lh_div = dwMCk / (dwTwCk * 2) - 4;

	/* cldiv must fit in 8 bits, ckdiv must fit in 3 bits */
	while ((c_lh_div > 0xFF) && (ckdiv < 7)) {
   80e96:	29ff      	cmp	r1, #255	; 0xff
   80e98:	d90e      	bls.n	80eb8 <_ZN12TwoWireClass5beginEv+0x94>
		/* Increase clock divider */
		ckdiv++;
		/* Divide cldiv value */
		c_lh_div /= 2;
   80e9a:	40e9      	lsrs	r1, r5
	}

	c_lh_div = dwMCk / (dwTwCk * 2) - 4;

	/* cldiv must fit in 8 bits, ckdiv must fit in 3 bits */
	while ((c_lh_div > 0xFF) && (ckdiv < 7)) {
   80e9c:	29ff      	cmp	r1, #255	; 0xff
		/* Increase clock divider */
		ckdiv++;
   80e9e:	bf98      	it	ls
   80ea0:	2307      	movls	r3, #7
	}

	c_lh_div = dwMCk / (dwTwCk * 2) - 4;

	/* cldiv must fit in 8 bits, ckdiv must fit in 3 bits */
	while ((c_lh_div > 0xFF) && (ckdiv < 7)) {
   80ea2:	d90a      	bls.n	80eba <_ZN12TwoWireClass5beginEv+0x96>
   80ea4:	f44f 23e0 	mov.w	r3, #458752	; 0x70000
		c_lh_div /= 2;
	}

	/* set clock waveform generator register */
	pTwi->TWI_CWGR =
	TWI_CWGR_CLDIV(c_lh_div) | TWI_CWGR_CHDIV(c_lh_div) |
   80ea8:	0208      	lsls	r0, r1, #8
   80eaa:	b2c9      	uxtb	r1, r1
   80eac:	b280      	uxth	r0, r0
   80eae:	4319      	orrs	r1, r3
   80eb0:	4301      	orrs	r1, r0
	TWI_CWGR_CKDIV(ckdiv);
   80eb2:	6111      	str	r1, [r2, #16]
	
	/* Configure clock*/
	if(TWI_SetClock(pTwi, dwTwCk, dwMCk) == 0u) 
		return 0u;
	
	return 1u;
   80eb4:	2001      	movs	r0, #1
   80eb6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	c_lh_div = dwMCk / (dwTwCk * 2) - 4;

	/* cldiv must fit in 8 bits, ckdiv must fit in 3 bits */
	while ((c_lh_div > 0xFF) && (ckdiv < 7)) {
		/* Increase clock divider */
		ckdiv++;
   80eb8:	2306      	movs	r3, #6
   80eba:	041b      	lsls	r3, r3, #16
   80ebc:	e7f4      	b.n	80ea8 <_ZN12TwoWireClass5beginEv+0x84>
   80ebe:	462b      	mov	r3, r5
   80ec0:	e7fb      	b.n	80eba <_ZN12TwoWireClass5beginEv+0x96>
   80ec2:	2302      	movs	r3, #2
   80ec4:	e7f9      	b.n	80eba <_ZN12TwoWireClass5beginEv+0x96>
   80ec6:	2303      	movs	r3, #3
   80ec8:	e7f7      	b.n	80eba <_ZN12TwoWireClass5beginEv+0x96>
   80eca:	4623      	mov	r3, r4
   80ecc:	e7f5      	b.n	80eba <_ZN12TwoWireClass5beginEv+0x96>
   80ece:	2305      	movs	r3, #5
   80ed0:	e7f3      	b.n	80eba <_ZN12TwoWireClass5beginEv+0x96>
   80ed2:	bf00      	nop
   80ed4:	00061a80 	.word	0x00061a80
   80ed8:	0501bd00 	.word	0x0501bd00

00080edc <_ZN12TwoWireClass17beginTransmissionEh>:
void TwoWireClass::beginTransmission(uint8_t slaveAddress){
	TWISTATUS = MASTER_SEND;
	TWIMESSAGE = TRANSMIT_START;
	
	Packet.chip = slaveAddress;
	Packet.iaddr[0] = 0u;
   80edc:	2300      	movs	r3, #0

	TWISTATUS = SLAVE_IDLE;
}

/** Prepares software for transmitting*/
void TwoWireClass::beginTransmission(uint8_t slaveAddress){
   80ede:	b410      	push	{r4}
	TWISTATUS = MASTER_SEND;
	TWIMESSAGE = TRANSMIT_START;
   80ee0:	2201      	movs	r2, #1
	TWISTATUS = SLAVE_IDLE;
}

/** Prepares software for transmitting*/
void TwoWireClass::beginTransmission(uint8_t slaveAddress){
	TWISTATUS = MASTER_SEND;
   80ee2:	2402      	movs	r4, #2
   80ee4:	7584      	strb	r4, [r0, #22]
	TWIMESSAGE = TRANSMIT_START;
	
	Packet.chip = slaveAddress;
   80ee6:	f880 1139 	strb.w	r1, [r0, #313]	; 0x139
	Packet.iaddr[0] = 0u;
   80eea:	f880 3130 	strb.w	r3, [r0, #304]	; 0x130
}

/** Prepares software for transmitting*/
void TwoWireClass::beginTransmission(uint8_t slaveAddress){
	TWISTATUS = MASTER_SEND;
	TWIMESSAGE = TRANSMIT_START;
   80eee:	7542      	strb	r2, [r0, #21]
	
	Packet.chip = slaveAddress;
	Packet.iaddr[0] = 0u;
	Packet.iaddr[1] = 0u;
   80ef0:	f880 3131 	strb.w	r3, [r0, #305]	; 0x131
	Packet.iaddr[2] = 0u;
   80ef4:	f880 3132 	strb.w	r3, [r0, #306]	; 0x132
	Packet.iaddr_length = 0u;
   80ef8:	f8c0 3134 	str.w	r3, [r0, #308]	; 0x134
	Packet.rxLength = 0u;
   80efc:	f880 3138 	strb.w	r3, [r0, #312]	; 0x138
}
   80f00:	bc10      	pop	{r4}
   80f02:	4770      	bx	lr

00080f04 <_ZN12TwoWireClass5writeEm>:

/** Writes a single byte into txBuffer or svBuffer **/
uint32_t TwoWireClass::write(uint32_t val){
	if(TWISTATUS == MASTER_SEND)
   80f04:	7d83      	ldrb	r3, [r0, #22]
   80f06:	2b02      	cmp	r3, #2
   80f08:	d003      	beq.n	80f12 <_ZN12TwoWireClass5writeEm+0xe>
		return txBuffer.write(val);
	else
		return svBuffer.write(val);
   80f0a:	f500 708e 	add.w	r0, r0, #284	; 0x11c
   80f0e:	4b02      	ldr	r3, [pc, #8]	; (80f18 <_ZN12TwoWireClass5writeEm+0x14>)
   80f10:	4718      	bx	r3
}

/** Writes a single byte into txBuffer or svBuffer **/
uint32_t TwoWireClass::write(uint32_t val){
	if(TWISTATUS == MASTER_SEND)
		return txBuffer.write(val);
   80f12:	3074      	adds	r0, #116	; 0x74
   80f14:	4b00      	ldr	r3, [pc, #0]	; (80f18 <_ZN12TwoWireClass5writeEm+0x14>)
   80f16:	4718      	bx	r3
   80f18:	000806f9 	.word	0x000806f9

00080f1c <_ZN12TwoWireClass15endTransmissionEv>:
	return rxBuffer.read();
}

/** Empties the transmit buffer by writing to slave device*/
void TwoWireClass::endTransmission(){
	TWIMESSAGE = TRANSMIT_ADDRESS;
   80f1c:	2202      	movs	r2, #2
   80f1e:	f240 33e9 	movw	r3, #1001	; 0x3e9
   80f22:	6981      	ldr	r1, [r0, #24]
   80f24:	7542      	strb	r2, [r0, #21]
   80f26:	e001      	b.n	80f2c <_ZN12TwoWireClass15endTransmissionEv+0x10>
	
	//Make certain that all previous read and write operations are finished
	while((twi->TWI_SR & TWI_SR_TXCOMP) != TWI_SR_TXCOMP){
		++timeout;
		
		if(timeout > XMIT_TIMEOUT)
   80f28:	3b01      	subs	r3, #1
   80f2a:	d050      	beq.n	80fce <_ZN12TwoWireClass15endTransmissionEv+0xb2>
uint32_t TwoWireClass::TWI_StartWrite(){
	bool iFlag = false; //Interrupt flag 
	uint32_t timeout = 0;
	
	//Make certain that all previous read and write operations are finished
	while((twi->TWI_SR & TWI_SR_TXCOMP) != TWI_SR_TXCOMP){
   80f2c:	6a0a      	ldr	r2, [r1, #32]
   80f2e:	07d2      	lsls	r2, r2, #31
   80f30:	d5fa      	bpl.n	80f28 <_ZN12TwoWireClass15endTransmissionEv+0xc>
uint8_t TwoWireClass::read(){
	return rxBuffer.read();
}

/** Empties the transmit buffer by writing to slave device*/
void TwoWireClass::endTransmission(){
   80f32:	b570      	push	{r4, r5, r6, lr}
	
	/* Dummy read to clear bits*/
	twi->TWI_SR;
	
	/* Set write mode, slave address, and internal address length */
	twi->TWI_MMR = 0;
   80f34:	2500      	movs	r5, #0
		if(timeout > XMIT_TIMEOUT)
			return 0u;
	}
	
	/* Dummy read to clear bits*/
	twi->TWI_SR;
   80f36:	6a0b      	ldr	r3, [r1, #32]
	
	/* Set write mode, slave address, and internal address length */
	twi->TWI_MMR = 0;
   80f38:	604d      	str	r5, [r1, #4]
	twi->TWI_MMR = TWI_MMR_DADR(Packet.chip) |
   80f3a:	f890 4139 	ldrb.w	r4, [r0, #313]	; 0x139
	((Packet.iaddr_length << TWI_MMR_IADRSZ_Pos) &
   80f3e:	f8d0 3134 	ldr.w	r3, [r0, #308]	; 0x134
	/* Dummy read to clear bits*/
	twi->TWI_SR;
	
	/* Set write mode, slave address, and internal address length */
	twi->TWI_MMR = 0;
	twi->TWI_MMR = TWI_MMR_DADR(Packet.chip) |
   80f42:	0424      	lsls	r4, r4, #16
   80f44:	021a      	lsls	r2, r3, #8
   80f46:	f404 04fe 	and.w	r4, r4, #8323072	; 0x7f0000
   80f4a:	f402 7240 	and.w	r2, r2, #768	; 0x300
   80f4e:	4322      	orrs	r2, r4
	((Packet.iaddr_length << TWI_MMR_IADRSZ_Pos) &
	TWI_MMR_IADRSZ_Msk);
   80f50:	604a      	str	r2, [r1, #4]
	
	/* Set internal address for remote chip */
	twi->TWI_IADR = 0;
   80f52:	60cd      	str	r5, [r1, #12]

uint32_t TWI_makeAddr(const uint8_t *addr, int len)
{
	uint32_t val;

	if (len == 0)
   80f54:	b16b      	cbz	r3, 80f72 <_ZN12TwoWireClass15endTransmissionEv+0x56>
	return 0;

	val = addr[0];
	if (len > 1) {
   80f56:	2b01      	cmp	r3, #1
	uint32_t val;

	if (len == 0)
	return 0;

	val = addr[0];
   80f58:	f890 4130 	ldrb.w	r4, [r0, #304]	; 0x130
	if (len > 1) {
   80f5c:	dd38      	ble.n	80fd0 <_ZN12TwoWireClass15endTransmissionEv+0xb4>
		val <<= 8;
		val |= addr[1];
   80f5e:	f890 2131 	ldrb.w	r2, [r0, #305]	; 0x131
	}
	if (len > 2) {
   80f62:	2b02      	cmp	r3, #2
	return 0;

	val = addr[0];
	if (len > 1) {
		val <<= 8;
		val |= addr[1];
   80f64:	ea42 2404 	orr.w	r4, r2, r4, lsl #8
	}
	if (len > 2) {
   80f68:	d032      	beq.n	80fd0 <_ZN12TwoWireClass15endTransmissionEv+0xb4>
		val <<= 8;
		val |= addr[2];
   80f6a:	f890 2132 	ldrb.w	r2, [r0, #306]	; 0x132
   80f6e:	ea42 2304 	orr.w	r3, r2, r4, lsl #8
	/* Set internal address for remote chip */
	twi->TWI_IADR = 0;
	twi->TWI_IADR = TWI_makeAddr(Packet.iaddr, Packet.iaddr_length);
	
	/* Is this the only byte we are sending? */
	if(txBuffer.availableToRead() == 1u){
   80f72:	f100 0574 	add.w	r5, r0, #116	; 0x74
	((Packet.iaddr_length << TWI_MMR_IADRSZ_Pos) &
	TWI_MMR_IADRSZ_Msk);
	
	/* Set internal address for remote chip */
	twi->TWI_IADR = 0;
	twi->TWI_IADR = TWI_makeAddr(Packet.iaddr, Packet.iaddr_length);
   80f76:	60cb      	str	r3, [r1, #12]
   80f78:	4604      	mov	r4, r0
	
	/* Is this the only byte we are sending? */
	if(txBuffer.availableToRead() == 1u){
   80f7a:	4b16      	ldr	r3, [pc, #88]	; (80fd4 <_ZN12TwoWireClass15endTransmissionEv+0xb8>)
   80f7c:	4628      	mov	r0, r5
   80f7e:	4798      	blx	r3
   80f80:	2801      	cmp	r0, #1
   80f82:	d00d      	beq.n	80fa0 <_ZN12TwoWireClass15endTransmissionEv+0x84>
		twi->TWI_CR |= TWI_CR_STOP;				 //Enable the stop bit at end of transmission
		iFlag = true;							 //Select the proper interrupts to fire
	}
	
	/* Enable start bit */
	twi->TWI_CR |= TWI_CR_START;
   80f84:	69a6      	ldr	r6, [r4, #24]
	
	/* Write first byte to send.*/
	twi->TWI_THR = txBuffer.read();
   80f86:	4a14      	ldr	r2, [pc, #80]	; (80fd8 <_ZN12TwoWireClass15endTransmissionEv+0xbc>)
		twi->TWI_CR |= TWI_CR_STOP;				 //Enable the stop bit at end of transmission
		iFlag = true;							 //Select the proper interrupts to fire
	}
	
	/* Enable start bit */
	twi->TWI_CR |= TWI_CR_START;
   80f88:	6833      	ldr	r3, [r6, #0]
	
	/* Write first byte to send.*/
	twi->TWI_THR = txBuffer.read();
   80f8a:	4628      	mov	r0, r5
		twi->TWI_CR |= TWI_CR_STOP;				 //Enable the stop bit at end of transmission
		iFlag = true;							 //Select the proper interrupts to fire
	}
	
	/* Enable start bit */
	twi->TWI_CR |= TWI_CR_START;
   80f8c:	f043 0301 	orr.w	r3, r3, #1
   80f90:	6033      	str	r3, [r6, #0]
	
	/* Write first byte to send.*/
	twi->TWI_THR = txBuffer.read();
   80f92:	4790      	blx	r2
	
	//Enable interrupts. This must be last or interrupts will be triggered immediately
	if(iFlag)
		TWI_EnableIt(twi, TWI_IER_NACK | TWI_IER_TXCOMP); //Last transmission
	else
		TWI_EnableIt(twi, TWI_IER_NACK | TWI_IER_TXRDY);  //More to go
   80f94:	69a3      	ldr	r3, [r4, #24]
 * \param pTwi  Pointer to an Twi instance.
 * \param sources  Bitwise OR of selected interrupt sources.
 */
void TWI_EnableIt(Twi *pTwi, uint32_t sources)
{
    pTwi->TWI_IER = sources;
   80f96:	f44f 7282 	mov.w	r2, #260	; 0x104
	
	/* Enable start bit */
	twi->TWI_CR |= TWI_CR_START;
	
	/* Write first byte to send.*/
	twi->TWI_THR = txBuffer.read();
   80f9a:	6370      	str	r0, [r6, #52]	; 0x34
 * \param pTwi  Pointer to an Twi instance.
 * \param sources  Bitwise OR of selected interrupt sources.
 */
void TWI_EnableIt(Twi *pTwi, uint32_t sources)
{
    pTwi->TWI_IER = sources;
   80f9c:	625a      	str	r2, [r3, #36]	; 0x24
   80f9e:	bd70      	pop	{r4, r5, r6, pc}
	twi->TWI_IADR = 0;
	twi->TWI_IADR = TWI_makeAddr(Packet.iaddr, Packet.iaddr_length);
	
	/* Is this the only byte we are sending? */
	if(txBuffer.availableToRead() == 1u){
		Packet.registerAccess = txBuffer.peek(); //Grab the register being accessed inside the slave
   80fa0:	4b0e      	ldr	r3, [pc, #56]	; (80fdc <_ZN12TwoWireClass15endTransmissionEv+0xc0>)
   80fa2:	4628      	mov	r0, r5
   80fa4:	4798      	blx	r3
		twi->TWI_CR |= TWI_CR_STOP;				 //Enable the stop bit at end of transmission
   80fa6:	69a6      	ldr	r6, [r4, #24]
	twi->TWI_IADR = 0;
	twi->TWI_IADR = TWI_makeAddr(Packet.iaddr, Packet.iaddr_length);
	
	/* Is this the only byte we are sending? */
	if(txBuffer.availableToRead() == 1u){
		Packet.registerAccess = txBuffer.peek(); //Grab the register being accessed inside the slave
   80fa8:	f884 013a 	strb.w	r0, [r4, #314]	; 0x13a
		twi->TWI_CR |= TWI_CR_STOP;				 //Enable the stop bit at end of transmission
   80fac:	6833      	ldr	r3, [r6, #0]
	
	/* Enable start bit */
	twi->TWI_CR |= TWI_CR_START;
	
	/* Write first byte to send.*/
	twi->TWI_THR = txBuffer.read();
   80fae:	4a0a      	ldr	r2, [pc, #40]	; (80fd8 <_ZN12TwoWireClass15endTransmissionEv+0xbc>)
	twi->TWI_IADR = TWI_makeAddr(Packet.iaddr, Packet.iaddr_length);
	
	/* Is this the only byte we are sending? */
	if(txBuffer.availableToRead() == 1u){
		Packet.registerAccess = txBuffer.peek(); //Grab the register being accessed inside the slave
		twi->TWI_CR |= TWI_CR_STOP;				 //Enable the stop bit at end of transmission
   80fb0:	f043 0302 	orr.w	r3, r3, #2
   80fb4:	6033      	str	r3, [r6, #0]
		iFlag = true;							 //Select the proper interrupts to fire
	}
	
	/* Enable start bit */
	twi->TWI_CR |= TWI_CR_START;
   80fb6:	6833      	ldr	r3, [r6, #0]
	
	/* Write first byte to send.*/
	twi->TWI_THR = txBuffer.read();
   80fb8:	4628      	mov	r0, r5
		twi->TWI_CR |= TWI_CR_STOP;				 //Enable the stop bit at end of transmission
		iFlag = true;							 //Select the proper interrupts to fire
	}
	
	/* Enable start bit */
	twi->TWI_CR |= TWI_CR_START;
   80fba:	f043 0301 	orr.w	r3, r3, #1
   80fbe:	6033      	str	r3, [r6, #0]
	
	/* Write first byte to send.*/
	twi->TWI_THR = txBuffer.read();
   80fc0:	4790      	blx	r2
 * \param pTwi  Pointer to an Twi instance.
 * \param sources  Bitwise OR of selected interrupt sources.
 */
void TWI_EnableIt(Twi *pTwi, uint32_t sources)
{
    pTwi->TWI_IER = sources;
   80fc2:	f240 1201 	movw	r2, #257	; 0x101
	/* Write first byte to send.*/
	twi->TWI_THR = txBuffer.read();
	
	//Enable interrupts. This must be last or interrupts will be triggered immediately
	if(iFlag)
		TWI_EnableIt(twi, TWI_IER_NACK | TWI_IER_TXCOMP); //Last transmission
   80fc6:	69a3      	ldr	r3, [r4, #24]
	
	/* Enable start bit */
	twi->TWI_CR |= TWI_CR_START;
	
	/* Write first byte to send.*/
	twi->TWI_THR = txBuffer.read();
   80fc8:	6370      	str	r0, [r6, #52]	; 0x34
 * \param pTwi  Pointer to an Twi instance.
 * \param sources  Bitwise OR of selected interrupt sources.
 */
void TWI_EnableIt(Twi *pTwi, uint32_t sources)
{
    pTwi->TWI_IER = sources;
   80fca:	625a      	str	r2, [r3, #36]	; 0x24
/** Empties the transmit buffer by writing to slave device*/
void TwoWireClass::endTransmission(){
	TWIMESSAGE = TRANSMIT_ADDRESS;
	
	TWI_StartWrite(); //Send the first byte off and let ISR handle rest of transmission
}
   80fcc:	bd70      	pop	{r4, r5, r6, pc}
   80fce:	4770      	bx	lr
	return 0;

	val = addr[0];
	if (len > 1) {
		val <<= 8;
		val |= addr[1];
   80fd0:	4623      	mov	r3, r4
   80fd2:	e7ce      	b.n	80f72 <_ZN12TwoWireClass15endTransmissionEv+0x56>
   80fd4:	00080789 	.word	0x00080789
   80fd8:	0008073d 	.word	0x0008073d
   80fdc:	0008077d 	.word	0x0008077d

00080fe0 <_ZN12TwoWireClass11requestFromEhh>:
	else
		TWI_EnableIt(twi, TWI_IER_NACK | TWI_IER_TXRDY);  //More to go
	return 1u;
}

void TwoWireClass::requestFrom(uint8_t slaveAddress, uint8_t quantity){
   80fe0:	b4f0      	push	{r4, r5, r6, r7}
	TWISTATUS = MASTER_RECV;
	TWIMESSAGE = RECEIVE_START;
	
	Packet.chip = slaveAddress;
   80fe2:	f880 1139 	strb.w	r1, [r0, #313]	; 0x139
		TWI_EnableIt(twi, TWI_IER_NACK | TWI_IER_TXRDY);  //More to go
	return 1u;
}

void TwoWireClass::requestFrom(uint8_t slaveAddress, uint8_t quantity){
	TWISTATUS = MASTER_RECV;
   80fe6:	2703      	movs	r7, #3
	TWIMESSAGE = RECEIVE_START;
	
	Packet.chip = slaveAddress;
	Packet.iaddr[0] = 0u;
   80fe8:	2100      	movs	r1, #0
	return 1u;
}

void TwoWireClass::requestFrom(uint8_t slaveAddress, uint8_t quantity){
	TWISTATUS = MASTER_RECV;
	TWIMESSAGE = RECEIVE_START;
   80fea:	2605      	movs	r6, #5
	//while(TWIMESSAGE != RECEIVE_SUCCESSFUL);
	
}

uint32_t TwoWireClass::TWI_StartRead(){
	TWIMESSAGE = TRANSMIT_ADDRESS;
   80fec:	2502      	movs	r5, #2
		TWI_EnableIt(twi, TWI_IER_NACK | TWI_IER_TXRDY);  //More to go
	return 1u;
}

void TwoWireClass::requestFrom(uint8_t slaveAddress, uint8_t quantity){
	TWISTATUS = MASTER_RECV;
   80fee:	7587      	strb	r7, [r0, #22]
	//while(TWIMESSAGE != RECEIVE_SUCCESSFUL);
	
}

uint32_t TwoWireClass::TWI_StartRead(){
	TWIMESSAGE = TRANSMIT_ADDRESS;
   80ff0:	f240 33e9 	movw	r3, #1001	; 0x3e9
	return 1u;
}

void TwoWireClass::requestFrom(uint8_t slaveAddress, uint8_t quantity){
	TWISTATUS = MASTER_RECV;
	TWIMESSAGE = RECEIVE_START;
   80ff4:	7546      	strb	r6, [r0, #21]
   80ff6:	6984      	ldr	r4, [r0, #24]
	Packet.iaddr[0] = 0u;
	Packet.iaddr[1] = 0u;
	Packet.iaddr[2] = 0u;
	Packet.iaddr_length = 0u;
	Packet.rxLength = quantity;
	leftToRead = quantity;
   80ff8:	f880 202d 	strb.w	r2, [r0, #45]	; 0x2d
	Packet.chip = slaveAddress;
	Packet.iaddr[0] = 0u;
	Packet.iaddr[1] = 0u;
	Packet.iaddr[2] = 0u;
	Packet.iaddr_length = 0u;
	Packet.rxLength = quantity;
   80ffc:	f880 2138 	strb.w	r2, [r0, #312]	; 0x138
void TwoWireClass::requestFrom(uint8_t slaveAddress, uint8_t quantity){
	TWISTATUS = MASTER_RECV;
	TWIMESSAGE = RECEIVE_START;
	
	Packet.chip = slaveAddress;
	Packet.iaddr[0] = 0u;
   81000:	f880 1130 	strb.w	r1, [r0, #304]	; 0x130
	Packet.iaddr[1] = 0u;
   81004:	f880 1131 	strb.w	r1, [r0, #305]	; 0x131
	Packet.iaddr[2] = 0u;
   81008:	f880 1132 	strb.w	r1, [r0, #306]	; 0x132
	//while(TWIMESSAGE != RECEIVE_SUCCESSFUL);
	
}

uint32_t TwoWireClass::TWI_StartRead(){
	TWIMESSAGE = TRANSMIT_ADDRESS;
   8100c:	7545      	strb	r5, [r0, #21]
	
	Packet.chip = slaveAddress;
	Packet.iaddr[0] = 0u;
	Packet.iaddr[1] = 0u;
	Packet.iaddr[2] = 0u;
	Packet.iaddr_length = 0u;
   8100e:	f8c0 1134 	str.w	r1, [r0, #308]	; 0x134
   81012:	e001      	b.n	81018 <_ZN12TwoWireClass11requestFromEhh+0x38>
	//Make sure all transmits have been completed before reading from slave.
	//MAJOR SCREWUPS otherwise. Complete bus failure.
	while((twi->TWI_SR & TWI_SR_TXCOMP) != TWI_SR_TXCOMP){
		++timeout;
		
		if(timeout > XMIT_TIMEOUT)
   81014:	3b01      	subs	r3, #1
   81016:	d01e      	beq.n	81056 <_ZN12TwoWireClass11requestFromEhh+0x76>
	TWIMESSAGE = TRANSMIT_ADDRESS;
	uint32_t timeout = 0;
	
	//Make sure all transmits have been completed before reading from slave.
	//MAJOR SCREWUPS otherwise. Complete bus failure.
	while((twi->TWI_SR & TWI_SR_TXCOMP) != TWI_SR_TXCOMP){
   81018:	6a22      	ldr	r2, [r4, #32]
   8101a:	07d2      	lsls	r2, r2, #31
   8101c:	d5fa      	bpl.n	81014 <_ZN12TwoWireClass11requestFromEhh+0x34>
	
	/* Dummy read to clear bits*/
	twi->TWI_SR;
	
	/* Set read mode, slave address, and internal address length */
	twi->TWI_MMR = 0;
   8101e:	2200      	movs	r2, #0
		if(timeout > XMIT_TIMEOUT)
		return 0u;
	};
	
	/* Dummy read to clear bits*/
	twi->TWI_SR;
   81020:	6a23      	ldr	r3, [r4, #32]
	
	/* Set read mode, slave address, and internal address length */
	twi->TWI_MMR = 0;
   81022:	6062      	str	r2, [r4, #4]
	twi->TWI_MMR = TWI_MMR_DADR(Packet.chip) | TWI_MMR_MREAD | 
   81024:	f890 3139 	ldrb.w	r3, [r0, #313]	; 0x139
   81028:	041b      	lsls	r3, r3, #16
   8102a:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
   8102e:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
	((Packet.iaddr_length << TWI_MMR_IADRSZ_Pos) &
	TWI_MMR_IADRSZ_Msk);
   81032:	6063      	str	r3, [r4, #4]
	
	
	/* Set internal address for remote chip */
	twi->TWI_IADR = 0;
   81034:	60e2      	str	r2, [r4, #12]
	twi->TWI_IADR = TWI_makeAddr(Packet.iaddr, Packet.iaddr_length);
   81036:	60e2      	str	r2, [r4, #12]
	
	
	/* Do we only need 1 byte from the slave? */
	if(Packet.rxLength == 1){
   81038:	f890 3138 	ldrb.w	r3, [r0, #312]	; 0x138
 * \param pTwi  Pointer to an Twi instance.
 * \param sources  Bitwise OR of selected interrupt sources.
 */
void TWI_EnableIt(Twi *pTwi, uint32_t sources)
{
    pTwi->TWI_IER = sources;
   8103c:	f44f 7281 	mov.w	r2, #258	; 0x102
	twi->TWI_IADR = 0;
	twi->TWI_IADR = TWI_makeAddr(Packet.iaddr, Packet.iaddr_length);
	
	
	/* Do we only need 1 byte from the slave? */
	if(Packet.rxLength == 1){
   81040:	2b01      	cmp	r3, #1
		//Start and stop bits must be set at same time. This begins transmission of slave addr.
		twi->TWI_CR &= ~(TWI_CR_START | TWI_CR_STOP);
   81042:	6823      	ldr	r3, [r4, #0]
	twi->TWI_IADR = 0;
	twi->TWI_IADR = TWI_makeAddr(Packet.iaddr, Packet.iaddr_length);
	
	
	/* Do we only need 1 byte from the slave? */
	if(Packet.rxLength == 1){
   81044:	d009      	beq.n	8105a <_ZN12TwoWireClass11requestFromEhh+0x7a>
		
		//Set interrupts and let ISR handler take care of the rest.
		TWI_EnableIt(twi, TWI_IER_NACK | TWI_IER_RXRDY);
	} else {
		//Set only the start bit to begin slave addr transmission
		twi->TWI_CR &= ~(TWI_CR_START);
   81046:	f023 0301 	bic.w	r3, r3, #1
   8104a:	6023      	str	r3, [r4, #0]
		twi->TWI_CR |= TWI_CR_START;
   8104c:	6823      	ldr	r3, [r4, #0]
   8104e:	f043 0301 	orr.w	r3, r3, #1
   81052:	6023      	str	r3, [r4, #0]
 * \param pTwi  Pointer to an Twi instance.
 * \param sources  Bitwise OR of selected interrupt sources.
 */
void TWI_EnableIt(Twi *pTwi, uint32_t sources)
{
    pTwi->TWI_IER = sources;
   81054:	6262      	str	r2, [r4, #36]	; 0x24
	
	//Also blocking....*sigh...fix this kludge code tomorrow.
	//Can't use a global flag that is modified in interrupt. Colliding access is possible.
	//while(TWIMESSAGE != RECEIVE_SUCCESSFUL);
	
}
   81056:	bcf0      	pop	{r4, r5, r6, r7}
   81058:	4770      	bx	lr
	
	
	/* Do we only need 1 byte from the slave? */
	if(Packet.rxLength == 1){
		//Start and stop bits must be set at same time. This begins transmission of slave addr.
		twi->TWI_CR &= ~(TWI_CR_START | TWI_CR_STOP);
   8105a:	f023 0303 	bic.w	r3, r3, #3
   8105e:	6023      	str	r3, [r4, #0]
		twi->TWI_CR |= TWI_CR_START | TWI_CR_STOP; //pg.715
   81060:	6823      	ldr	r3, [r4, #0]
   81062:	f043 0303 	orr.w	r3, r3, #3
   81066:	6023      	str	r3, [r4, #0]
 * \param pTwi  Pointer to an Twi instance.
 * \param sources  Bitwise OR of selected interrupt sources.
 */
void TWI_EnableIt(Twi *pTwi, uint32_t sources)
{
    pTwi->TWI_IER = sources;
   81068:	6262      	str	r2, [r4, #36]	; 0x24
	
	//Also blocking....*sigh...fix this kludge code tomorrow.
	//Can't use a global flag that is modified in interrupt. Colliding access is possible.
	//while(TWIMESSAGE != RECEIVE_SUCCESSFUL);
	
}
   8106a:	bcf0      	pop	{r4, r5, r6, r7}
   8106c:	4770      	bx	lr
   8106e:	bf00      	nop

00081070 <_ZN12TwoWireClass10IRQHandlerEv>:
 * \param pTwi  Pointer to an Twi instance.
 * \param sources  Bitwise OR of selected interrupt sources.
 */
void TWI_DisableIt(Twi *pTwi, uint32_t sources)
{
    pTwi->TWI_IDR = sources;
   81070:	f240 1207 	movw	r2, #263	; 0x107
	}
	return 1u; //Success
}

/** Interrupt Handler*/
void TwoWireClass::IRQHandler(){
   81074:	b570      	push	{r4, r5, r6, lr}
   81076:	4604      	mov	r4, r0
	//Read status register
	uint32_t status = twi->TWI_SR;
   81078:	6983      	ldr	r3, [r0, #24]
	
	//Disable interrupts so we don't accidentally loop upon next transmit
	TWI_DisableIt(twi, TWI_IDR_NACK | TWI_IDR_TXRDY | TWI_IDR_TXCOMP | TWI_IDR_RXRDY);
	
	//Dummy indicator to make sure we made it here
	digitalWrite(25, HIGH);
   8107a:	2101      	movs	r1, #1
}

/** Interrupt Handler*/
void TwoWireClass::IRQHandler(){
	//Read status register
	uint32_t status = twi->TWI_SR;
   8107c:	6a1e      	ldr	r6, [r3, #32]
	
	//Disable interrupts so we don't accidentally loop upon next transmit
	TWI_DisableIt(twi, TWI_IDR_NACK | TWI_IDR_TXRDY | TWI_IDR_TXCOMP | TWI_IDR_RXRDY);
	
	//Dummy indicator to make sure we made it here
	digitalWrite(25, HIGH);
   8107e:	2019      	movs	r0, #25
 * \param pTwi  Pointer to an Twi instance.
 * \param sources  Bitwise OR of selected interrupt sources.
 */
void TWI_DisableIt(Twi *pTwi, uint32_t sources)
{
    pTwi->TWI_IDR = sources;
   81080:	629a      	str	r2, [r3, #40]	; 0x28
	
	//Disable interrupts so we don't accidentally loop upon next transmit
	TWI_DisableIt(twi, TWI_IDR_NACK | TWI_IDR_TXRDY | TWI_IDR_TXCOMP | TWI_IDR_RXRDY);
	
	//Dummy indicator to make sure we made it here
	digitalWrite(25, HIGH);
   81082:	4d42      	ldr	r5, [pc, #264]	; (8118c <_ZN12TwoWireClass10IRQHandlerEv+0x11c>)
   81084:	47a8      	blx	r5
	digitalWrite(25, LOW);
   81086:	2100      	movs	r1, #0
   81088:	2019      	movs	r0, #25
   8108a:	47a8      	blx	r5
	
	if(TWISTATUS == MASTER_SEND){
   8108c:	7da3      	ldrb	r3, [r4, #22]
   8108e:	2b02      	cmp	r3, #2
   81090:	d00c      	beq.n	810ac <_ZN12TwoWireClass10IRQHandlerEv+0x3c>
			return;
		}
	} //End of TWISTATUS == MASTER_SEND
	
	
	if(TWISTATUS == MASTER_RECV){
   81092:	7da3      	ldrb	r3, [r4, #22]
   81094:	2b03      	cmp	r3, #3
   81096:	d000      	beq.n	8109a <_ZN12TwoWireClass10IRQHandlerEv+0x2a>
   81098:	bd70      	pop	{r4, r5, r6, pc}
		
		//No ACK received from slave? Figure out when it occurred.
		if((status & TWI_SR_NACK) == TWI_SR_NACK){
   8109a:	05f3      	lsls	r3, r6, #23
   8109c:	d523      	bpl.n	810e6 <_ZN12TwoWireClass10IRQHandlerEv+0x76>
			
			if(TWIMESSAGE == TRANSMIT_ADDRESS){
   8109e:	7d63      	ldrb	r3, [r4, #21]
   810a0:	2b02      	cmp	r3, #2
				TWIERROR = ERROR_NACK_ON_ADDRESS_TRANSMIT;
   810a2:	bf04      	itt	eq
   810a4:	2301      	moveq	r3, #1
   810a6:	7523      	strbeq	r3, [r4, #20]
				//			1) Number of retries or time? Probably should use Scheduler.
				//			2) Upon max failures: clear transmit buffer, alert main program of problem
			}
			
			
			if(TWIMESSAGE == RECEIVE_DATA){
   810a8:	7d63      	ldrb	r3, [r4, #21]
   810aa:	bd70      	pop	{r4, r5, r6, pc}
	digitalWrite(25, HIGH);
	digitalWrite(25, LOW);
	
	if(TWISTATUS == MASTER_SEND){
		//No ACK received from slave? Figure out when it occurred.
		if((status & TWI_SR_NACK) == TWI_SR_NACK){
   810ac:	05f1      	lsls	r1, r6, #23
   810ae:	d50e      	bpl.n	810ce <_ZN12TwoWireClass10IRQHandlerEv+0x5e>
		
			if(TWIMESSAGE == TRANSMIT_ADDRESS){
   810b0:	7d63      	ldrb	r3, [r4, #21]
   810b2:	2b02      	cmp	r3, #2
				TWIERROR = ERROR_NACK_ON_ADDRESS_TRANSMIT;
   810b4:	bf04      	itt	eq
   810b6:	2301      	moveq	r3, #1
   810b8:	7523      	strbeq	r3, [r4, #20]
				//To Do: Options for retry and timeout
				//			1) Number of retries or time? Probably should use Scheduler.
				//			2) Upon max failures: clear transmit buffer, alert main program of problem
			}
		
			if(TWIMESSAGE == TRANSMIT_DATA){
   810ba:	7d63      	ldrb	r3, [r4, #21]
   810bc:	2b03      	cmp	r3, #3
   810be:	d1eb      	bne.n	81098 <_ZN12TwoWireClass10IRQHandlerEv+0x28>
			
				//At this point, the data buffer has been read from and all
				//past data cannot be recovered. Purge buffer and alert main program
				//to retry. This could probably be improved upon.
				txBuffer.flush();
   810c0:	4b33      	ldr	r3, [pc, #204]	; (81190 <_ZN12TwoWireClass10IRQHandlerEv+0x120>)
   810c2:	f104 0074 	add.w	r0, r4, #116	; 0x74
   810c6:	4798      	blx	r3
				TWIERROR = ERROR_NACK_DURING_TRANSMIT;
   810c8:	2302      	movs	r3, #2
   810ca:	7523      	strb	r3, [r4, #20]
   810cc:	bd70      	pop	{r4, r5, r6, pc}
			}
			return;
		}
	
		//Error Free! Continue sending data as needed.
		uint32_t dataLeft = txBuffer.availableToRead();
   810ce:	f104 0574 	add.w	r5, r4, #116	; 0x74
   810d2:	4b30      	ldr	r3, [pc, #192]	; (81194 <_ZN12TwoWireClass10IRQHandlerEv+0x124>)
   810d4:	4628      	mov	r0, r5
   810d6:	4798      	blx	r3
		bool iFlag = false;
	
		if(dataLeft > 0){
   810d8:	4603      	mov	r3, r0
   810da:	bb40      	cbnz	r0, 8112e <_ZN12TwoWireClass10IRQHandlerEv+0xbe>
			return;
		}
	
	
		//Data transmit completed with no errors. Tidy up transmission.
		if((status & TWI_SR_TXCOMP) == TWI_SR_TXCOMP){
   810dc:	07f2      	lsls	r2, r6, #31
   810de:	d447      	bmi.n	81170 <_ZN12TwoWireClass10IRQHandlerEv+0x100>
			return;
		}
	} //End of TWISTATUS == MASTER_SEND
	
	
	if(TWISTATUS == MASTER_RECV){
   810e0:	7da3      	ldrb	r3, [r4, #22]
   810e2:	2b03      	cmp	r3, #3
   810e4:	d1d8      	bne.n	81098 <_ZN12TwoWireClass10IRQHandlerEv+0x28>
			}
			return;
		}
		
		//No errors! We may proceed with reading data
		if(leftToRead > 0){
   810e6:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
   810ea:	b1ab      	cbz	r3, 81118 <_ZN12TwoWireClass10IRQHandlerEv+0xa8>
			TWIMESSAGE = RECEIVE_DATA;
   810ec:	2306      	movs	r3, #6
   810ee:	7563      	strb	r3, [r4, #21]
			
			//Enable stop bit if next to last receive
			if(leftToRead == 1)
   810f0:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
   810f4:	2b01      	cmp	r3, #1
				twi->TWI_CR |= TWI_CR_STOP;
   810f6:	69a3      	ldr	r3, [r4, #24]
		//No errors! We may proceed with reading data
		if(leftToRead > 0){
			TWIMESSAGE = RECEIVE_DATA;
			
			//Enable stop bit if next to last receive
			if(leftToRead == 1)
   810f8:	d035      	beq.n	81166 <_ZN12TwoWireClass10IRQHandlerEv+0xf6>
				twi->TWI_CR |= TWI_CR_STOP;
			
			//Read data from slave
			rxBuffer.write(twi->TWI_RHR);
   810fa:	6b19      	ldr	r1, [r3, #48]	; 0x30
   810fc:	f104 00c8 	add.w	r0, r4, #200	; 0xc8
   81100:	4b25      	ldr	r3, [pc, #148]	; (81198 <_ZN12TwoWireClass10IRQHandlerEv+0x128>)
   81102:	4798      	blx	r3
			--leftToRead;	
   81104:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
				
				
			//Ensure interrupts are enabled
			TWI_EnableIt(twi, TWI_IER_NACK | TWI_IER_RXRDY);
   81108:	69a2      	ldr	r2, [r4, #24]
			if(leftToRead == 1)
				twi->TWI_CR |= TWI_CR_STOP;
			
			//Read data from slave
			rxBuffer.write(twi->TWI_RHR);
			--leftToRead;	
   8110a:	3b01      	subs	r3, #1
   8110c:	b2db      	uxtb	r3, r3
 * \param pTwi  Pointer to an Twi instance.
 * \param sources  Bitwise OR of selected interrupt sources.
 */
void TWI_EnableIt(Twi *pTwi, uint32_t sources)
{
    pTwi->TWI_IER = sources;
   8110e:	f44f 7181 	mov.w	r1, #258	; 0x102
			if(leftToRead == 1)
				twi->TWI_CR |= TWI_CR_STOP;
			
			//Read data from slave
			rxBuffer.write(twi->TWI_RHR);
			--leftToRead;	
   81112:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
 * \param pTwi  Pointer to an Twi instance.
 * \param sources  Bitwise OR of selected interrupt sources.
 */
void TWI_EnableIt(Twi *pTwi, uint32_t sources)
{
    pTwi->TWI_IER = sources;
   81116:	6251      	str	r1, [r2, #36]	; 0x24
			//Ensure interrupts are enabled
			TWI_EnableIt(twi, TWI_IER_NACK | TWI_IER_RXRDY);
		}
		
		//Looks like we're done here
		if(leftToRead == 0){
   81118:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
   8111c:	2b00      	cmp	r3, #0
   8111e:	d1bb      	bne.n	81098 <_ZN12TwoWireClass10IRQHandlerEv+0x28>
			TWIMESSAGE = RECEIVE_SUCCESSFUL;
			
			//Ensure interrupts are disabled
			TWI_DisableIt(twi, TWI_IDR_NACK | TWI_IDR_RXRDY);
   81120:	69a3      	ldr	r3, [r4, #24]
			TWI_EnableIt(twi, TWI_IER_NACK | TWI_IER_RXRDY);
		}
		
		//Looks like we're done here
		if(leftToRead == 0){
			TWIMESSAGE = RECEIVE_SUCCESSFUL;
   81122:	2107      	movs	r1, #7
 * \param pTwi  Pointer to an Twi instance.
 * \param sources  Bitwise OR of selected interrupt sources.
 */
void TWI_DisableIt(Twi *pTwi, uint32_t sources)
{
    pTwi->TWI_IDR = sources;
   81124:	f44f 7281 	mov.w	r2, #258	; 0x102
			TWI_EnableIt(twi, TWI_IER_NACK | TWI_IER_RXRDY);
		}
		
		//Looks like we're done here
		if(leftToRead == 0){
			TWIMESSAGE = RECEIVE_SUCCESSFUL;
   81128:	7561      	strb	r1, [r4, #21]
 * \param pTwi  Pointer to an Twi instance.
 * \param sources  Bitwise OR of selected interrupt sources.
 */
void TWI_DisableIt(Twi *pTwi, uint32_t sources)
{
    pTwi->TWI_IDR = sources;
   8112a:	629a      	str	r2, [r3, #40]	; 0x28
   8112c:	bd70      	pop	{r4, r5, r6, pc}
		uint32_t dataLeft = txBuffer.availableToRead();
		bool iFlag = false;
	
		if(dataLeft > 0){
			//Update the status
			TWIMESSAGE = TRANSMIT_DATA;
   8112e:	2203      	movs	r2, #3
		
			//Is this the last byte of data to send?
			if(dataLeft == 1){
   81130:	2801      	cmp	r0, #1
		uint32_t dataLeft = txBuffer.availableToRead();
		bool iFlag = false;
	
		if(dataLeft > 0){
			//Update the status
			TWIMESSAGE = TRANSMIT_DATA;
   81132:	7562      	strb	r2, [r4, #21]
		
			//Is this the last byte of data to send?
			if(dataLeft == 1){
   81134:	d009      	beq.n	8114a <_ZN12TwoWireClass10IRQHandlerEv+0xda>
				twi->TWI_CR |= TWI_CR_STOP;	//Enable the stop bit at end of transmission
				iFlag = true;				//Set "finishing" interrupts to fire
			}
		
			//Write data
			twi->TWI_THR = txBuffer.read();
   81136:	4628      	mov	r0, r5
   81138:	4b18      	ldr	r3, [pc, #96]	; (8119c <_ZN12TwoWireClass10IRQHandlerEv+0x12c>)
   8113a:	69a5      	ldr	r5, [r4, #24]
   8113c:	4798      	blx	r3
		
			//Enable interrupts. This must be last or interrupts will be triggered immediately
			if(iFlag)
				TWI_EnableIt(twi, TWI_IER_NACK | TWI_IER_TXCOMP); //Last transmission
			else
				TWI_EnableIt(twi, TWI_IER_NACK | TWI_IER_TXRDY);  //More data to go
   8113e:	69a3      	ldr	r3, [r4, #24]
 * \param pTwi  Pointer to an Twi instance.
 * \param sources  Bitwise OR of selected interrupt sources.
 */
void TWI_EnableIt(Twi *pTwi, uint32_t sources)
{
    pTwi->TWI_IER = sources;
   81140:	f44f 7282 	mov.w	r2, #260	; 0x104
				twi->TWI_CR |= TWI_CR_STOP;	//Enable the stop bit at end of transmission
				iFlag = true;				//Set "finishing" interrupts to fire
			}
		
			//Write data
			twi->TWI_THR = txBuffer.read();
   81144:	6368      	str	r0, [r5, #52]	; 0x34
 * \param pTwi  Pointer to an Twi instance.
 * \param sources  Bitwise OR of selected interrupt sources.
 */
void TWI_EnableIt(Twi *pTwi, uint32_t sources)
{
    pTwi->TWI_IER = sources;
   81146:	625a      	str	r2, [r3, #36]	; 0x24
   81148:	bd70      	pop	{r4, r5, r6, pc}
			//Update the status
			TWIMESSAGE = TRANSMIT_DATA;
		
			//Is this the last byte of data to send?
			if(dataLeft == 1){
				twi->TWI_CR |= TWI_CR_STOP;	//Enable the stop bit at end of transmission
   8114a:	69a6      	ldr	r6, [r4, #24]
				iFlag = true;				//Set "finishing" interrupts to fire
			}
		
			//Write data
			twi->TWI_THR = txBuffer.read();
   8114c:	4a13      	ldr	r2, [pc, #76]	; (8119c <_ZN12TwoWireClass10IRQHandlerEv+0x12c>)
			//Update the status
			TWIMESSAGE = TRANSMIT_DATA;
		
			//Is this the last byte of data to send?
			if(dataLeft == 1){
				twi->TWI_CR |= TWI_CR_STOP;	//Enable the stop bit at end of transmission
   8114e:	6833      	ldr	r3, [r6, #0]
				iFlag = true;				//Set "finishing" interrupts to fire
			}
		
			//Write data
			twi->TWI_THR = txBuffer.read();
   81150:	4628      	mov	r0, r5
			//Update the status
			TWIMESSAGE = TRANSMIT_DATA;
		
			//Is this the last byte of data to send?
			if(dataLeft == 1){
				twi->TWI_CR |= TWI_CR_STOP;	//Enable the stop bit at end of transmission
   81152:	f043 0302 	orr.w	r3, r3, #2
   81156:	6033      	str	r3, [r6, #0]
				iFlag = true;				//Set "finishing" interrupts to fire
			}
		
			//Write data
			twi->TWI_THR = txBuffer.read();
   81158:	4790      	blx	r2
 * \param pTwi  Pointer to an Twi instance.
 * \param sources  Bitwise OR of selected interrupt sources.
 */
void TWI_EnableIt(Twi *pTwi, uint32_t sources)
{
    pTwi->TWI_IER = sources;
   8115a:	f240 1201 	movw	r2, #257	; 0x101
			//Write data
			twi->TWI_THR = txBuffer.read();
		
			//Enable interrupts. This must be last or interrupts will be triggered immediately
			if(iFlag)
				TWI_EnableIt(twi, TWI_IER_NACK | TWI_IER_TXCOMP); //Last transmission
   8115e:	69a3      	ldr	r3, [r4, #24]
				twi->TWI_CR |= TWI_CR_STOP;	//Enable the stop bit at end of transmission
				iFlag = true;				//Set "finishing" interrupts to fire
			}
		
			//Write data
			twi->TWI_THR = txBuffer.read();
   81160:	6370      	str	r0, [r6, #52]	; 0x34
 * \param pTwi  Pointer to an Twi instance.
 * \param sources  Bitwise OR of selected interrupt sources.
 */
void TWI_EnableIt(Twi *pTwi, uint32_t sources)
{
    pTwi->TWI_IER = sources;
   81162:	625a      	str	r2, [r3, #36]	; 0x24
   81164:	bd70      	pop	{r4, r5, r6, pc}
		if(leftToRead > 0){
			TWIMESSAGE = RECEIVE_DATA;
			
			//Enable stop bit if next to last receive
			if(leftToRead == 1)
				twi->TWI_CR |= TWI_CR_STOP;
   81166:	681a      	ldr	r2, [r3, #0]
   81168:	f042 0202 	orr.w	r2, r2, #2
   8116c:	601a      	str	r2, [r3, #0]
   8116e:	e7c4      	b.n	810fa <_ZN12TwoWireClass10IRQHandlerEv+0x8a>
		}
	
	
		//Data transmit completed with no errors. Tidy up transmission.
		if((status & TWI_SR_TXCOMP) == TWI_SR_TXCOMP){
			TWISTATUS = MASTER_IDLE;
   81170:	2201      	movs	r2, #1
			TWIERROR = NO_ERROR;
			TWIMESSAGE = TRANSMIT_SUCCESSFUL;
   81172:	2104      	movs	r1, #4
		}
	
	
		//Data transmit completed with no errors. Tidy up transmission.
		if((status & TWI_SR_TXCOMP) == TWI_SR_TXCOMP){
			TWISTATUS = MASTER_IDLE;
   81174:	75a2      	strb	r2, [r4, #22]
			TWIERROR = NO_ERROR;
			TWIMESSAGE = TRANSMIT_SUCCESSFUL;
			
			//Clean buffer
			txBuffer.flush();
   81176:	4628      	mov	r0, r5
	
	
		//Data transmit completed with no errors. Tidy up transmission.
		if((status & TWI_SR_TXCOMP) == TWI_SR_TXCOMP){
			TWISTATUS = MASTER_IDLE;
			TWIERROR = NO_ERROR;
   81178:	7523      	strb	r3, [r4, #20]
			TWIMESSAGE = TRANSMIT_SUCCESSFUL;
			
			//Clean buffer
			txBuffer.flush();
   8117a:	4a05      	ldr	r2, [pc, #20]	; (81190 <_ZN12TwoWireClass10IRQHandlerEv+0x120>)
	
		//Data transmit completed with no errors. Tidy up transmission.
		if((status & TWI_SR_TXCOMP) == TWI_SR_TXCOMP){
			TWISTATUS = MASTER_IDLE;
			TWIERROR = NO_ERROR;
			TWIMESSAGE = TRANSMIT_SUCCESSFUL;
   8117c:	7561      	strb	r1, [r4, #21]
			
			//Clean buffer
			txBuffer.flush();
   8117e:	4790      	blx	r2
 * \param pTwi  Pointer to an Twi instance.
 * \param sources  Bitwise OR of selected interrupt sources.
 */
void TWI_DisableIt(Twi *pTwi, uint32_t sources)
{
    pTwi->TWI_IDR = sources;
   81180:	f240 1205 	movw	r2, #261	; 0x105
			
			//Clean buffer
			txBuffer.flush();
			
			//Make sure interrupts are disabled
			TWI_DisableIt(twi, TWI_IDR_NACK | TWI_IDR_TXRDY | TWI_IDR_TXCOMP);
   81184:	69a3      	ldr	r3, [r4, #24]
 * \param pTwi  Pointer to an Twi instance.
 * \param sources  Bitwise OR of selected interrupt sources.
 */
void TWI_DisableIt(Twi *pTwi, uint32_t sources)
{
    pTwi->TWI_IDR = sources;
   81186:	629a      	str	r2, [r3, #40]	; 0x28
   81188:	bd70      	pop	{r4, r5, r6, pc}
   8118a:	bf00      	nop
   8118c:	00080571 	.word	0x00080571
   81190:	000806e5 	.word	0x000806e5
   81194:	00080789 	.word	0x00080789
   81198:	000806f9 	.word	0x000806f9
   8119c:	0008073d 	.word	0x0008073d

000811a0 <_ZN9UARTClassC1Ev>:
 */ 

#include "../libraries.h"

//Constructor
UARTClass::UARTClass(){
   811a0:	b538      	push	{r3, r4, r5, lr}
   811a2:	4604      	mov	r4, r0
   811a4:	4b08      	ldr	r3, [pc, #32]	; (811c8 <_ZN9UARTClassC1Ev+0x28>)
   811a6:	4798      	blx	r3
   811a8:	4d08      	ldr	r5, [pc, #32]	; (811cc <_ZN9UARTClassC1Ev+0x2c>)
   811aa:	f104 0114 	add.w	r1, r4, #20
   811ae:	f104 0094 	add.w	r0, r4, #148	; 0x94
   811b2:	2210      	movs	r2, #16
   811b4:	47a8      	blx	r5
   811b6:	f104 0154 	add.w	r1, r4, #84	; 0x54
   811ba:	f104 00a8 	add.w	r0, r4, #168	; 0xa8
   811be:	2210      	movs	r2, #16
   811c0:	47a8      	blx	r5
}
   811c2:	4620      	mov	r0, r4
   811c4:	bd38      	pop	{r3, r4, r5, pc}
   811c6:	bf00      	nop
   811c8:	000806bd 	.word	0x000806bd
   811cc:	000806c1 	.word	0x000806c1

000811d0 <_ZN9UARTClass10IrqHandlerEv>:
		default: return 0u;
	}
}
 

void UARTClass::IrqHandler(void){
   811d0:	b538      	push	{r3, r4, r5, lr}
	uint32_t status = UART->UART_SR;
   811d2:	4b13      	ldr	r3, [pc, #76]	; (81220 <_ZN9UARTClass10IrqHandlerEv+0x50>)
		default: return 0u;
	}
}
 

void UARTClass::IrqHandler(void){
   811d4:	4605      	mov	r5, r0
	uint32_t status = UART->UART_SR;
   811d6:	695c      	ldr	r4, [r3, #20]
	
	//Did we receive data?
	if ((status & UART_SR_RXRDY) == UART_SR_RXRDY)
   811d8:	07e2      	lsls	r2, r4, #31
   811da:	d40a      	bmi.n	811f2 <_ZN9UARTClass10IrqHandlerEv+0x22>
		rxBuffer.write(UART->UART_RHR);

	//Do we need to keep sending data?
	if ((status & UART_SR_TXRDY) == UART_SR_TXRDY){
   811dc:	07a3      	lsls	r3, r4, #30
   811de:	d40e      	bmi.n	811fe <_ZN9UARTClass10IrqHandlerEv+0x2e>
		else
			UART->UART_IDR = UART_IDR_TXRDY;  //Turn off interrupt. No more data left.
	}

	// Acknowledge errors
	if ((status & UART_SR_OVRE) == UART_SR_OVRE || (status & UART_SR_FRAME) == UART_SR_FRAME){
   811e0:	f014 0f60 	tst.w	r4, #96	; 0x60
   811e4:	d004      	beq.n	811f0 <_ZN9UARTClass10IrqHandlerEv+0x20>
		// TODO: error reporting outside ISR
		UART->UART_CR |= UART_CR_RSTSTA;
   811e6:	4a0e      	ldr	r2, [pc, #56]	; (81220 <_ZN9UARTClass10IrqHandlerEv+0x50>)
   811e8:	6813      	ldr	r3, [r2, #0]
   811ea:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   811ee:	6013      	str	r3, [r2, #0]
   811f0:	bd38      	pop	{r3, r4, r5, pc}
void UARTClass::IrqHandler(void){
	uint32_t status = UART->UART_SR;
	
	//Did we receive data?
	if ((status & UART_SR_RXRDY) == UART_SR_RXRDY)
		rxBuffer.write(UART->UART_RHR);
   811f2:	6999      	ldr	r1, [r3, #24]
   811f4:	3094      	adds	r0, #148	; 0x94
   811f6:	4b0b      	ldr	r3, [pc, #44]	; (81224 <_ZN9UARTClass10IrqHandlerEv+0x54>)
   811f8:	4798      	blx	r3

	//Do we need to keep sending data?
	if ((status & UART_SR_TXRDY) == UART_SR_TXRDY){
   811fa:	07a3      	lsls	r3, r4, #30
   811fc:	d5f0      	bpl.n	811e0 <_ZN9UARTClass10IrqHandlerEv+0x10>
		//Is data available to send?
		if (txBuffer.availableToRead())
   811fe:	35a8      	adds	r5, #168	; 0xa8
   81200:	4628      	mov	r0, r5
   81202:	4b09      	ldr	r3, [pc, #36]	; (81228 <_ZN9UARTClass10IrqHandlerEv+0x58>)
   81204:	4798      	blx	r3
   81206:	b918      	cbnz	r0, 81210 <_ZN9UARTClass10IrqHandlerEv+0x40>
			UART->UART_THR = (uint8_t)txBuffer.read();
		else
			UART->UART_IDR = UART_IDR_TXRDY;  //Turn off interrupt. No more data left.
   81208:	4b05      	ldr	r3, [pc, #20]	; (81220 <_ZN9UARTClass10IrqHandlerEv+0x50>)
   8120a:	2202      	movs	r2, #2
   8120c:	60da      	str	r2, [r3, #12]
   8120e:	e7e7      	b.n	811e0 <_ZN9UARTClass10IrqHandlerEv+0x10>

	//Do we need to keep sending data?
	if ((status & UART_SR_TXRDY) == UART_SR_TXRDY){
		//Is data available to send?
		if (txBuffer.availableToRead())
			UART->UART_THR = (uint8_t)txBuffer.read();
   81210:	4b06      	ldr	r3, [pc, #24]	; (8122c <_ZN9UARTClass10IrqHandlerEv+0x5c>)
   81212:	4628      	mov	r0, r5
   81214:	4798      	blx	r3
   81216:	4b02      	ldr	r3, [pc, #8]	; (81220 <_ZN9UARTClass10IrqHandlerEv+0x50>)
   81218:	b2c0      	uxtb	r0, r0
   8121a:	61d8      	str	r0, [r3, #28]
   8121c:	e7e0      	b.n	811e0 <_ZN9UARTClass10IrqHandlerEv+0x10>
   8121e:	bf00      	nop
   81220:	400e0800 	.word	0x400e0800
   81224:	000806f9 	.word	0x000806f9
   81228:	00080789 	.word	0x00080789
   8122c:	0008073d 	.word	0x0008073d

00081230 <_ZN10USARTClassC1Em>:
//TX1 & RX1 are USART0 -> Serial1


#include "../libraries.h"

USARTClass::USARTClass(uint32_t channel){
   81230:	b570      	push	{r4, r5, r6, lr}
   81232:	4604      	mov	r4, r0
   81234:	460d      	mov	r5, r1
   81236:	4b17      	ldr	r3, [pc, #92]	; (81294 <_ZN10USARTClassC1Em+0x64>)
   81238:	4798      	blx	r3
   8123a:	4e17      	ldr	r6, [pc, #92]	; (81298 <_ZN10USARTClassC1Em+0x68>)
   8123c:	f104 0134 	add.w	r1, r4, #52	; 0x34
   81240:	2296      	movs	r2, #150	; 0x96
   81242:	f204 40e4 	addw	r0, r4, #1252	; 0x4e4
   81246:	47b0      	blx	r6
   81248:	f504 7123 	add.w	r1, r4, #652	; 0x28c
   8124c:	f504 609f 	add.w	r0, r4, #1272	; 0x4f8
   81250:	2296      	movs	r2, #150	; 0x96
   81252:	47b0      	blx	r6

	switch(channel)
   81254:	2d02      	cmp	r5, #2
   81256:	d017      	beq.n	81288 <_ZN10USARTClassC1Em+0x58>
   81258:	2d03      	cmp	r5, #3
   8125a:	d010      	beq.n	8127e <_ZN10USARTClassC1Em+0x4e>
   8125c:	2d01      	cmp	r5, #1
   8125e:	d001      	beq.n	81264 <_ZN10USARTClassC1Em+0x34>
		break;
		default: return;
	}
	
	initialized = false;
}
   81260:	4620      	mov	r0, r4
   81262:	bd70      	pop	{r4, r5, r6, pc}
USARTClass::USARTClass(uint32_t channel){

	switch(channel)
	{
		case 1:
		instance = USART0;
   81264:	480d      	ldr	r0, [pc, #52]	; (8129c <_ZN10USARTClassC1Em+0x6c>)
		instanceID = ID_USART0;
   81266:	2311      	movs	r3, #17
		IRQNum = USART0_IRQn;
		txPin  = 18;
   81268:	2112      	movs	r1, #18
		rxPin  = 19;
   8126a:	2213      	movs	r2, #19
		rxPin  = 17;
		break;
		
		case 3:
		instance = USART3;
		instanceID = ID_USART3;
   8126c:	61e3      	str	r3, [r4, #28]
		IRQNum = USART3_IRQn;
   8126e:	7623      	strb	r3, [r4, #24]
		rxPin  = 15;
		break;
		default: return;
	}
	
	initialized = false;
   81270:	2300      	movs	r3, #0
		txPin  = 16;
		rxPin  = 17;
		break;
		
		case 3:
		instance = USART3;
   81272:	6160      	str	r0, [r4, #20]
		instanceID = ID_USART3;
		IRQNum = USART3_IRQn;
		txPin  = 14;
   81274:	62a1      	str	r1, [r4, #40]	; 0x28
		rxPin  = 15;
   81276:	6262      	str	r2, [r4, #36]	; 0x24
		break;
		default: return;
	}
	
	initialized = false;
   81278:	6323      	str	r3, [r4, #48]	; 0x30
}
   8127a:	4620      	mov	r0, r4
   8127c:	bd70      	pop	{r4, r5, r6, pc}
		txPin  = 16;
		rxPin  = 17;
		break;
		
		case 3:
		instance = USART3;
   8127e:	4808      	ldr	r0, [pc, #32]	; (812a0 <_ZN10USARTClassC1Em+0x70>)
		instanceID = ID_USART3;
   81280:	2314      	movs	r3, #20
		IRQNum = USART3_IRQn;
		txPin  = 14;
   81282:	210e      	movs	r1, #14
		rxPin  = 15;
   81284:	220f      	movs	r2, #15
   81286:	e7f1      	b.n	8126c <_ZN10USARTClassC1Em+0x3c>
		txPin  = 18;
		rxPin  = 19;
		break;
		
		case 2:
		instance = USART1;
   81288:	4806      	ldr	r0, [pc, #24]	; (812a4 <_ZN10USARTClassC1Em+0x74>)
		instanceID = ID_USART1;
   8128a:	2312      	movs	r3, #18
		IRQNum = USART1_IRQn;
		txPin  = 16;
   8128c:	2110      	movs	r1, #16
		rxPin  = 17;
   8128e:	2211      	movs	r2, #17
   81290:	e7ec      	b.n	8126c <_ZN10USARTClassC1Em+0x3c>
   81292:	bf00      	nop
   81294:	000806bd 	.word	0x000806bd
   81298:	000806c1 	.word	0x000806c1
   8129c:	40098000 	.word	0x40098000
   812a0:	400a4000 	.word	0x400a4000
   812a4:	4009c000 	.word	0x4009c000

000812a8 <_ZN10USARTClass5beginEv>:
	}
	
	initialized = false;
}

void USARTClass::begin(){
   812a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	init();
}

void USARTClass::init(){
	//Has the USART channel already been initialized?
	if(initialized)
   812ac:	6b06      	ldr	r6, [r0, #48]	; 0x30
	
	initialized = false;
}

void USARTClass::begin(){
	baud = 115200;
   812ae:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
	instanceMode = US_MR_USART_MODE_NORMAL | US_MR_USCLKS_MCK| US_MR_CHMODE_NORMAL | US_MR_CHRL_8_BIT|
					US_MR_PAR_NO;
   812b2:	f44f 630c 	mov.w	r3, #2240	; 0x8c0
	}
	
	initialized = false;
}

void USARTClass::begin(){
   812b6:	b082      	sub	sp, #8
	baud = 115200;
   812b8:	62c2      	str	r2, [r0, #44]	; 0x2c
	instanceMode = US_MR_USART_MODE_NORMAL | US_MR_USCLKS_MCK| US_MR_CHMODE_NORMAL | US_MR_CHRL_8_BIT|
					US_MR_PAR_NO;
   812ba:	6203      	str	r3, [r0, #32]
	init();
}

void USARTClass::init(){
	//Has the USART channel already been initialized?
	if(initialized)
   812bc:	b116      	cbz	r6, 812c4 <_ZN10USARTClass5beginEv+0x1c>
void USARTClass::begin(){
	baud = 115200;
	instanceMode = US_MR_USART_MODE_NORMAL | US_MR_USCLKS_MCK| US_MR_CHMODE_NORMAL | US_MR_CHRL_8_BIT|
					US_MR_PAR_NO;
	init();
}
   812be:	b002      	add	sp, #8
   812c0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   812c4:	4604      	mov	r4, r0
	if(initialized)
	return;
	
	//Initialize pins and hand control over to peripheral.
	PIO_configurePin(
	pinCharacteristic[txPin].port,
   812c6:	6a83      	ldr	r3, [r0, #40]	; 0x28
	pinCharacteristic[txPin].pinMask,
	pinCharacteristic[txPin].peripheralType,
	pinCharacteristic[txPin].pinAttribute,
   812c8:	4d30      	ldr	r5, [pc, #192]	; (8138c <_ZN10USARTClass5beginEv+0xe4>)
   812ca:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
   812ce:	009b      	lsls	r3, r3, #2
   812d0:	18e9      	adds	r1, r5, r3
	OUTPUT);
   812d2:	58e8      	ldr	r0, [r5, r3]
   812d4:	7b0a      	ldrb	r2, [r1, #12]
   812d6:	694b      	ldr	r3, [r1, #20]
   812d8:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 8139c <_ZN10USARTClass5beginEv+0xf4>
   812dc:	6849      	ldr	r1, [r1, #4]
   812de:	9600      	str	r6, [sp, #0]
   812e0:	47c0      	blx	r8
	
	PIO_configurePin(
	pinCharacteristic[rxPin].port,
   812e2:	6a63      	ldr	r3, [r4, #36]	; 0x24
	pinCharacteristic[rxPin].pinMask,
	pinCharacteristic[rxPin].peripheralType,
	pinCharacteristic[rxPin].pinAttribute,
	INPUT);
   812e4:	2701      	movs	r7, #1
	
	PIO_configurePin(
	pinCharacteristic[rxPin].port,
	pinCharacteristic[rxPin].pinMask,
	pinCharacteristic[rxPin].peripheralType,
	pinCharacteristic[rxPin].pinAttribute,
   812e6:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
   812ea:	009b      	lsls	r3, r3, #2
   812ec:	18e9      	adds	r1, r5, r3
	INPUT);
   812ee:	7b0a      	ldrb	r2, [r1, #12]
   812f0:	58e8      	ldr	r0, [r5, r3]
   812f2:	694b      	ldr	r3, [r1, #20]
   812f4:	6849      	ldr	r1, [r1, #4]
   812f6:	9700      	str	r7, [sp, #0]
   812f8:	47c0      	blx	r8
	
	USART_Configure(instance, instanceID, IRQNum, instanceMode, baud);
   812fa:	f8d4 a02c 	ldr.w	sl, [r4, #44]	; 0x2c
/* Exported Functions                                                   */
/************************************************************************/

void USART_Configure(Usart *usartInstance, uint32_t periphID, IRQn_Type IRQID, uint32_t mode, uint32_t baudRate){
	//Turn on peripheral clock
	pmc_enable_periph_clk(periphID);
   812fe:	4b24      	ldr	r3, [pc, #144]	; (81390 <_ZN10USARTClass5beginEv+0xe8>)
   81300:	69e0      	ldr	r0, [r4, #28]
	pinCharacteristic[rxPin].pinMask,
	pinCharacteristic[rxPin].peripheralType,
	pinCharacteristic[rxPin].pinAttribute,
	INPUT);
	
	USART_Configure(instance, instanceID, IRQNum, instanceMode, baud);
   81302:	6965      	ldr	r5, [r4, #20]
   81304:	f994 8018 	ldrsb.w	r8, [r4, #24]
   81308:	f8d4 9020 	ldr.w	r9, [r4, #32]
/* Exported Functions                                                   */
/************************************************************************/

void USART_Configure(Usart *usartInstance, uint32_t periphID, IRQn_Type IRQID, uint32_t mode, uint32_t baudRate){
	//Turn on peripheral clock
	pmc_enable_periph_clk(periphID);
   8130c:	4798      	blx	r3
	
	//Disable PDC Requests
	usartInstance->US_PTCR = US_PTCR_RXTDIS | US_PTCR_TXTDIS;
   8130e:	f240 2002 	movw	r0, #514	; 0x202
	
	//Set the mode: Normal Channel, Master Clock, 8 Bit, and whatever is defined in usartMode
	usartInstance->US_MR = mode;
	
	//Set the Baud Rate
	usartInstance->US_BRGR = clockDivisor(baudRate);
   81312:	4920      	ldr	r1, [pc, #128]	; (81394 <_ZN10USARTClass5beginEv+0xec>)
   81314:	ea4f 1a0a 	mov.w	sl, sl, lsl #4
   81318:	fbb1 f1fa 	udiv	r1, r1, sl
   8131c:	ea4f 1358 	mov.w	r3, r8, lsr #5

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
   81320:	fa5f f288 	uxtb.w	r2, r8
   81324:	009b      	lsls	r3, r3, #2
void USART_Configure(Usart *usartInstance, uint32_t periphID, IRQn_Type IRQID, uint32_t mode, uint32_t baudRate){
	//Turn on peripheral clock
	pmc_enable_periph_clk(periphID);
	
	//Disable PDC Requests
	usartInstance->US_PTCR = US_PTCR_RXTDIS | US_PTCR_TXTDIS;
   81326:	f8c5 0120 	str.w	r0, [r5, #288]	; 0x120
   8132a:	f002 0e1f 	and.w	lr, r2, #31
	
	//Reset TX, RX & Status Register. Disable TX & RX
	usartInstance->US_CR = US_CR_RSTRX | US_CR_RSTTX | US_CR_RXDIS | US_CR_TXDIS | US_CR_RSTSTA;
   8132e:	f44f 70d6 	mov.w	r0, #428	; 0x1ac
   81332:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
   81336:	6028      	str	r0, [r5, #0]
   81338:	fa07 f70e 	lsl.w	r7, r7, lr
   8133c:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
	
	//Set the Baud Rate
	usartInstance->US_BRGR = clockDivisor(baudRate);
	
	//Disable all interrupts and then config
	usartInstance->US_IDR = 0xFFFFFFFF;
   81340:	f04f 30ff 	mov.w	r0, #4294967295
    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
   81344:	f1b8 0f00 	cmp.w	r8, #0
	
	//Reset TX, RX & Status Register. Disable TX & RX
	usartInstance->US_CR = US_CR_RSTRX | US_CR_RSTTX | US_CR_RXDIS | US_CR_TXDIS | US_CR_RSTSTA;
	
	//Set the mode: Normal Channel, Master Clock, 8 Bit, and whatever is defined in usartMode
	usartInstance->US_MR = mode;
   81348:	f8c5 9004 	str.w	r9, [r5, #4]
	
	//Set the Baud Rate
	usartInstance->US_BRGR = clockDivisor(baudRate);
   8134c:	6229      	str	r1, [r5, #32]
	
	//Disable all interrupts and then config
	usartInstance->US_IDR = 0xFFFFFFFF;
   8134e:	60e8      	str	r0, [r5, #12]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
   81350:	f8c3 7080 	str.w	r7, [r3, #128]	; 0x80

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
   81354:	f8c3 7180 	str.w	r7, [r3, #384]	; 0x180
    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
   81358:	db12      	blt.n	81380 <_ZN10USARTClass5beginEv+0xd8>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
   8135a:	f108 4260 	add.w	r2, r8, #3758096384	; 0xe0000000
   8135e:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
   81362:	f882 6300 	strb.w	r6, [r2, #768]	; 0x300
	NVIC_DisableIRQ(IRQID);
	NVIC_ClearPendingIRQ(IRQID);
	NVIC_SetPriority(IRQID, (uint32_t)PRIOR_SERIAL);
	NVIC_EnableIRQ(IRQID);
	usartInstance->US_IER = US_IER_RXRDY;
   81366:	2201      	movs	r2, #1

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
   81368:	601f      	str	r7, [r3, #0]
   8136a:	60aa      	str	r2, [r5, #8]
	
	//Enable TX & RX
	usartInstance->US_CR &= ~(US_CR_RSTRX | US_CR_RSTTX | US_CR_RXDIS | US_CR_TXDIS | US_CR_RSTSTA);
   8136c:	682b      	ldr	r3, [r5, #0]
	usartInstance->US_CR = US_CR_RXEN | US_CR_TXEN;
   8136e:	2150      	movs	r1, #80	; 0x50
	NVIC_SetPriority(IRQID, (uint32_t)PRIOR_SERIAL);
	NVIC_EnableIRQ(IRQID);
	usartInstance->US_IER = US_IER_RXRDY;
	
	//Enable TX & RX
	usartInstance->US_CR &= ~(US_CR_RSTRX | US_CR_RSTTX | US_CR_RXDIS | US_CR_TXDIS | US_CR_RSTSTA);
   81370:	f423 73d6 	bic.w	r3, r3, #428	; 0x1ac
   81374:	602b      	str	r3, [r5, #0]
	usartInstance->US_CR = US_CR_RXEN | US_CR_TXEN;
   81376:	6029      	str	r1, [r5, #0]
	INPUT);
	
	USART_Configure(instance, instanceID, IRQNum, instanceMode, baud);
	
	//Lock out this function from further use.
	initialized = true;
   81378:	6322      	str	r2, [r4, #48]	; 0x30
void USARTClass::begin(){
	baud = 115200;
	instanceMode = US_MR_USART_MODE_NORMAL | US_MR_USCLKS_MCK| US_MR_CHMODE_NORMAL | US_MR_CHRL_8_BIT|
					US_MR_PAR_NO;
	init();
}
   8137a:	b002      	add	sp, #8
   8137c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
   81380:	4905      	ldr	r1, [pc, #20]	; (81398 <_ZN10USARTClass5beginEv+0xf0>)
   81382:	f002 020f 	and.w	r2, r2, #15
   81386:	4411      	add	r1, r2
   81388:	760e      	strb	r6, [r1, #24]
   8138a:	e7ec      	b.n	81366 <_ZN10USARTClass5beginEv+0xbe>
   8138c:	000815e4 	.word	0x000815e4
   81390:	00080679 	.word	0x00080679
   81394:	0501bd00 	.word	0x0501bd00
   81398:	e000ecfc 	.word	0xe000ecfc
   8139c:	000805b9 	.word	0x000805b9

000813a0 <_ZN10USARTClass10IrqHandlerEv>:
		
		default: return 0u;
	}
}

void USARTClass::IrqHandler(void){
   813a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t status = instance->US_CSR;
   813a2:	6943      	ldr	r3, [r0, #20]
		
		default: return 0u;
	}
}

void USARTClass::IrqHandler(void){
   813a4:	4605      	mov	r5, r0
	uint32_t status = instance->US_CSR;
   813a6:	695c      	ldr	r4, [r3, #20]
	
	// Did we receive data?
	if((status & US_CSR_RXRDY) == US_CSR_RXRDY)
   813a8:	07e2      	lsls	r2, r4, #31
   813aa:	d40a      	bmi.n	813c2 <_ZN10USARTClass10IrqHandlerEv+0x22>
		rxBuffer.write(instance->US_RHR); //8bit format

	// Do we need to keep sending data?
	if((status & US_CSR_TXRDY) == US_CSR_TXRDY)
   813ac:	07a3      	lsls	r3, r4, #30
   813ae:	d40f      	bmi.n	813d0 <_ZN10USARTClass10IrqHandlerEv+0x30>
		else
			instance->US_IDR |= US_IDR_TXRDY; //Turn off interrupt. No more data left.
	}

	// Acknowledge errors
	if ((status & US_CSR_OVRE) == US_CSR_OVRE || (status & US_CSR_FRAME) == US_CSR_FRAME)
   813b0:	f014 0f60 	tst.w	r4, #96	; 0x60
   813b4:	d004      	beq.n	813c0 <_ZN10USARTClass10IrqHandlerEv+0x20>
	{
		// TODO: error reporting outside ISR
		instance->US_CR |= US_CR_RSTSTA;
   813b6:	696a      	ldr	r2, [r5, #20]
   813b8:	6813      	ldr	r3, [r2, #0]
   813ba:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   813be:	6013      	str	r3, [r2, #0]
   813c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
void USARTClass::IrqHandler(void){
	uint32_t status = instance->US_CSR;
	
	// Did we receive data?
	if((status & US_CSR_RXRDY) == US_CSR_RXRDY)
		rxBuffer.write(instance->US_RHR); //8bit format
   813c2:	6999      	ldr	r1, [r3, #24]
   813c4:	f200 40e4 	addw	r0, r0, #1252	; 0x4e4
   813c8:	4b0d      	ldr	r3, [pc, #52]	; (81400 <_ZN10USARTClass10IrqHandlerEv+0x60>)
   813ca:	4798      	blx	r3

	// Do we need to keep sending data?
	if((status & US_CSR_TXRDY) == US_CSR_TXRDY)
   813cc:	07a3      	lsls	r3, r4, #30
   813ce:	d5ef      	bpl.n	813b0 <_ZN10USARTClass10IrqHandlerEv+0x10>
	{
		if(txBuffer.availableToRead()){
   813d0:	f505 669f 	add.w	r6, r5, #1272	; 0x4f8
   813d4:	4630      	mov	r0, r6
   813d6:	4b0b      	ldr	r3, [pc, #44]	; (81404 <_ZN10USARTClass10IrqHandlerEv+0x64>)
   813d8:	4798      	blx	r3
   813da:	b928      	cbnz	r0, 813e8 <_ZN10USARTClass10IrqHandlerEv+0x48>
			
			//Send the data
			instance->US_THR = (uint8_t)txBuffer.read();
		}
		else
			instance->US_IDR |= US_IDR_TXRDY; //Turn off interrupt. No more data left.
   813dc:	696a      	ldr	r2, [r5, #20]
   813de:	68d3      	ldr	r3, [r2, #12]
   813e0:	f043 0302 	orr.w	r3, r3, #2
   813e4:	60d3      	str	r3, [r2, #12]
   813e6:	e7e3      	b.n	813b0 <_ZN10USARTClass10IrqHandlerEv+0x10>
	// Do we need to keep sending data?
	if((status & US_CSR_TXRDY) == US_CSR_TXRDY)
	{
		if(txBuffer.availableToRead()){
			//Make sure interrupts are still enabled
			instance->US_IER |= US_IER_TXRDY;
   813e8:	696f      	ldr	r7, [r5, #20]
			
			//Send the data
			instance->US_THR = (uint8_t)txBuffer.read();
   813ea:	4630      	mov	r0, r6
	// Do we need to keep sending data?
	if((status & US_CSR_TXRDY) == US_CSR_TXRDY)
	{
		if(txBuffer.availableToRead()){
			//Make sure interrupts are still enabled
			instance->US_IER |= US_IER_TXRDY;
   813ec:	68bb      	ldr	r3, [r7, #8]
			
			//Send the data
			instance->US_THR = (uint8_t)txBuffer.read();
   813ee:	4a06      	ldr	r2, [pc, #24]	; (81408 <_ZN10USARTClass10IrqHandlerEv+0x68>)
	// Do we need to keep sending data?
	if((status & US_CSR_TXRDY) == US_CSR_TXRDY)
	{
		if(txBuffer.availableToRead()){
			//Make sure interrupts are still enabled
			instance->US_IER |= US_IER_TXRDY;
   813f0:	f043 0302 	orr.w	r3, r3, #2
   813f4:	60bb      	str	r3, [r7, #8]
			
			//Send the data
			instance->US_THR = (uint8_t)txBuffer.read();
   813f6:	4790      	blx	r2
   813f8:	b2c0      	uxtb	r0, r0
   813fa:	61f8      	str	r0, [r7, #28]
   813fc:	e7d8      	b.n	813b0 <_ZN10USARTClass10IrqHandlerEv+0x10>
   813fe:	bf00      	nop
   81400:	000806f9 	.word	0x000806f9
   81404:	00080789 	.word	0x00080789
   81408:	0008073d 	.word	0x0008073d

0008140c <__libc_init_array>:
   8140c:	b570      	push	{r4, r5, r6, lr}
   8140e:	4e0f      	ldr	r6, [pc, #60]	; (8144c <__libc_init_array+0x40>)
   81410:	4d0f      	ldr	r5, [pc, #60]	; (81450 <__libc_init_array+0x44>)
   81412:	1b76      	subs	r6, r6, r5
   81414:	10b6      	asrs	r6, r6, #2
   81416:	bf18      	it	ne
   81418:	2400      	movne	r4, #0
   8141a:	d005      	beq.n	81428 <__libc_init_array+0x1c>
   8141c:	3401      	adds	r4, #1
   8141e:	f855 3b04 	ldr.w	r3, [r5], #4
   81422:	4798      	blx	r3
   81424:	42a6      	cmp	r6, r4
   81426:	d1f9      	bne.n	8141c <__libc_init_array+0x10>
   81428:	4e0a      	ldr	r6, [pc, #40]	; (81454 <__libc_init_array+0x48>)
   8142a:	4d0b      	ldr	r5, [pc, #44]	; (81458 <__libc_init_array+0x4c>)
   8142c:	f000 fdf4 	bl	82018 <_init>
   81430:	1b76      	subs	r6, r6, r5
   81432:	10b6      	asrs	r6, r6, #2
   81434:	bf18      	it	ne
   81436:	2400      	movne	r4, #0
   81438:	d006      	beq.n	81448 <__libc_init_array+0x3c>
   8143a:	3401      	adds	r4, #1
   8143c:	f855 3b04 	ldr.w	r3, [r5], #4
   81440:	4798      	blx	r3
   81442:	42a6      	cmp	r6, r4
   81444:	d1f9      	bne.n	8143a <__libc_init_array+0x2e>
   81446:	bd70      	pop	{r4, r5, r6, pc}
   81448:	bd70      	pop	{r4, r5, r6, pc}
   8144a:	bf00      	nop
   8144c:	00082024 	.word	0x00082024
   81450:	00082024 	.word	0x00082024
   81454:	00082034 	.word	0x00082034
   81458:	00082024 	.word	0x00082024

0008145c <memset>:
   8145c:	b470      	push	{r4, r5, r6}
   8145e:	0784      	lsls	r4, r0, #30
   81460:	d046      	beq.n	814f0 <memset+0x94>
   81462:	1e54      	subs	r4, r2, #1
   81464:	2a00      	cmp	r2, #0
   81466:	d041      	beq.n	814ec <memset+0x90>
   81468:	b2cd      	uxtb	r5, r1
   8146a:	4603      	mov	r3, r0
   8146c:	e002      	b.n	81474 <memset+0x18>
   8146e:	1e62      	subs	r2, r4, #1
   81470:	b3e4      	cbz	r4, 814ec <memset+0x90>
   81472:	4614      	mov	r4, r2
   81474:	f803 5b01 	strb.w	r5, [r3], #1
   81478:	079a      	lsls	r2, r3, #30
   8147a:	d1f8      	bne.n	8146e <memset+0x12>
   8147c:	2c03      	cmp	r4, #3
   8147e:	d92e      	bls.n	814de <memset+0x82>
   81480:	b2cd      	uxtb	r5, r1
   81482:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
   81486:	2c0f      	cmp	r4, #15
   81488:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
   8148c:	d919      	bls.n	814c2 <memset+0x66>
   8148e:	4626      	mov	r6, r4
   81490:	f103 0210 	add.w	r2, r3, #16
   81494:	3e10      	subs	r6, #16
   81496:	2e0f      	cmp	r6, #15
   81498:	f842 5c10 	str.w	r5, [r2, #-16]
   8149c:	f842 5c0c 	str.w	r5, [r2, #-12]
   814a0:	f842 5c08 	str.w	r5, [r2, #-8]
   814a4:	f842 5c04 	str.w	r5, [r2, #-4]
   814a8:	f102 0210 	add.w	r2, r2, #16
   814ac:	d8f2      	bhi.n	81494 <memset+0x38>
   814ae:	f1a4 0210 	sub.w	r2, r4, #16
   814b2:	f022 020f 	bic.w	r2, r2, #15
   814b6:	f004 040f 	and.w	r4, r4, #15
   814ba:	3210      	adds	r2, #16
   814bc:	2c03      	cmp	r4, #3
   814be:	4413      	add	r3, r2
   814c0:	d90d      	bls.n	814de <memset+0x82>
   814c2:	461e      	mov	r6, r3
   814c4:	4622      	mov	r2, r4
   814c6:	3a04      	subs	r2, #4
   814c8:	2a03      	cmp	r2, #3
   814ca:	f846 5b04 	str.w	r5, [r6], #4
   814ce:	d8fa      	bhi.n	814c6 <memset+0x6a>
   814d0:	1f22      	subs	r2, r4, #4
   814d2:	f022 0203 	bic.w	r2, r2, #3
   814d6:	3204      	adds	r2, #4
   814d8:	4413      	add	r3, r2
   814da:	f004 0403 	and.w	r4, r4, #3
   814de:	b12c      	cbz	r4, 814ec <memset+0x90>
   814e0:	b2c9      	uxtb	r1, r1
   814e2:	441c      	add	r4, r3
   814e4:	f803 1b01 	strb.w	r1, [r3], #1
   814e8:	42a3      	cmp	r3, r4
   814ea:	d1fb      	bne.n	814e4 <memset+0x88>
   814ec:	bc70      	pop	{r4, r5, r6}
   814ee:	4770      	bx	lr
   814f0:	4614      	mov	r4, r2
   814f2:	4603      	mov	r3, r0
   814f4:	e7c2      	b.n	8147c <memset+0x20>
   814f6:	bf00      	nop

000814f8 <register_fini>:
   814f8:	4b02      	ldr	r3, [pc, #8]	; (81504 <register_fini+0xc>)
   814fa:	b113      	cbz	r3, 81502 <register_fini+0xa>
   814fc:	4802      	ldr	r0, [pc, #8]	; (81508 <register_fini+0x10>)
   814fe:	f000 b805 	b.w	8150c <atexit>
   81502:	4770      	bx	lr
   81504:	00000000 	.word	0x00000000
   81508:	00081519 	.word	0x00081519

0008150c <atexit>:
   8150c:	2300      	movs	r3, #0
   8150e:	4601      	mov	r1, r0
   81510:	461a      	mov	r2, r3
   81512:	4618      	mov	r0, r3
   81514:	f000 b814 	b.w	81540 <__register_exitproc>

00081518 <__libc_fini_array>:
   81518:	b538      	push	{r3, r4, r5, lr}
   8151a:	4d07      	ldr	r5, [pc, #28]	; (81538 <__libc_fini_array+0x20>)
   8151c:	4c07      	ldr	r4, [pc, #28]	; (8153c <__libc_fini_array+0x24>)
   8151e:	1b2c      	subs	r4, r5, r4
   81520:	10a4      	asrs	r4, r4, #2
   81522:	d005      	beq.n	81530 <__libc_fini_array+0x18>
   81524:	3c01      	subs	r4, #1
   81526:	f855 3d04 	ldr.w	r3, [r5, #-4]!
   8152a:	4798      	blx	r3
   8152c:	2c00      	cmp	r4, #0
   8152e:	d1f9      	bne.n	81524 <__libc_fini_array+0xc>
   81530:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   81534:	f000 bd7e 	b.w	82034 <_fini>
   81538:	00082044 	.word	0x00082044
   8153c:	00082040 	.word	0x00082040

00081540 <__register_exitproc>:
   81540:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   81544:	4c25      	ldr	r4, [pc, #148]	; (815dc <__register_exitproc+0x9c>)
   81546:	4606      	mov	r6, r0
   81548:	6825      	ldr	r5, [r4, #0]
   8154a:	4688      	mov	r8, r1
   8154c:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
   81550:	4692      	mov	sl, r2
   81552:	4699      	mov	r9, r3
   81554:	b3c4      	cbz	r4, 815c8 <__register_exitproc+0x88>
   81556:	6860      	ldr	r0, [r4, #4]
   81558:	281f      	cmp	r0, #31
   8155a:	dc17      	bgt.n	8158c <__register_exitproc+0x4c>
   8155c:	1c41      	adds	r1, r0, #1
   8155e:	b176      	cbz	r6, 8157e <__register_exitproc+0x3e>
   81560:	eb04 0380 	add.w	r3, r4, r0, lsl #2
   81564:	f8c3 a088 	str.w	sl, [r3, #136]	; 0x88
   81568:	f8d4 5188 	ldr.w	r5, [r4, #392]	; 0x188
   8156c:	2201      	movs	r2, #1
   8156e:	4082      	lsls	r2, r0
   81570:	4315      	orrs	r5, r2
   81572:	2e02      	cmp	r6, #2
   81574:	f8c4 5188 	str.w	r5, [r4, #392]	; 0x188
   81578:	f8c3 9108 	str.w	r9, [r3, #264]	; 0x108
   8157c:	d01e      	beq.n	815bc <__register_exitproc+0x7c>
   8157e:	1c83      	adds	r3, r0, #2
   81580:	6061      	str	r1, [r4, #4]
   81582:	2000      	movs	r0, #0
   81584:	f844 8023 	str.w	r8, [r4, r3, lsl #2]
   81588:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   8158c:	4b14      	ldr	r3, [pc, #80]	; (815e0 <__register_exitproc+0xa0>)
   8158e:	b303      	cbz	r3, 815d2 <__register_exitproc+0x92>
   81590:	f44f 70c8 	mov.w	r0, #400	; 0x190
   81594:	f3af 8000 	nop.w
   81598:	4604      	mov	r4, r0
   8159a:	b1d0      	cbz	r0, 815d2 <__register_exitproc+0x92>
   8159c:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
   815a0:	2700      	movs	r7, #0
   815a2:	e884 0088 	stmia.w	r4, {r3, r7}
   815a6:	4638      	mov	r0, r7
   815a8:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
   815ac:	2101      	movs	r1, #1
   815ae:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
   815b2:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
   815b6:	2e00      	cmp	r6, #0
   815b8:	d0e1      	beq.n	8157e <__register_exitproc+0x3e>
   815ba:	e7d1      	b.n	81560 <__register_exitproc+0x20>
   815bc:	f8d4 318c 	ldr.w	r3, [r4, #396]	; 0x18c
   815c0:	431a      	orrs	r2, r3
   815c2:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
   815c6:	e7da      	b.n	8157e <__register_exitproc+0x3e>
   815c8:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
   815cc:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
   815d0:	e7c1      	b.n	81556 <__register_exitproc+0x16>
   815d2:	f04f 30ff 	mov.w	r0, #4294967295
   815d6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   815da:	bf00      	nop
   815dc:	00082014 	.word	0x00082014
   815e0:	00000000 	.word	0x00000000

000815e4 <pinCharacteristic>:
   815e4:	400e0e00 00000100 0000000b 00000001     ...@............
   815f4:	00000000 00000004 ffffffff 400e0e00     ...............@
   81604:	00000200 0000000b 00000001 00000000     ................
   81614:	00000004 ffffffff 400e1000 02000000     ...........@....
   81624:	0000000c 00000002 00000000 00000014     ................
   81634:	00ffffff 400e1200 10000000 0000000d     .......@........
   81644:	00000002 00000000 00000014 0effffff     ................
   81654:	400e1200 04000000 0000000d 00000002     ...@............
   81664:	00000000 00000014 0dffffff 400e1200     ...............@
   81674:	02000000 0000000d 00000002 00000000     ................
   81684:	00000014 0cffffff 400e1200 01000000     ...........@....
   81694:	0000000d 00000002 00000000 0000000c     ................
   816a4:	ff07ffff 400e1200 00800000 0000000d     .......@........
   816b4:	00000002 00000000 0000000c ff06ffff     ................
   816c4:	400e1200 00400000 0000000d 00000002     ...@..@.........
   816d4:	00000000 0000000c ff05ffff 400e1200     ...............@
   816e4:	00200000 0000000d 00000002 00000000     .. .............
   816f4:	0000000c ff04ffff 400e1200 20000000     ...........@... 
   81704:	0000000d 00000002 00000000 00000014     ................
   81714:	0fffffff 400e1400 00000080 0000000e     .......@........
   81724:	00000002 00000000 00000014 10ffffff     ................
   81734:	400e1400 00000100 0000000e 00000002     ...@............
   81744:	00000000 00000014 11ffffff 400e1000     ...............@
   81754:	08000000 0000000c 00000002 00000000     ................
   81764:	00000014 01ffffff 400e1400 00000010     ...........@....
   81774:	0000000e 00000002 00000000 00000004     ................
   81784:	ffffffff 400e1400 00000020 0000000e     .......@ .......
   81794:	00000002 00000000 00000004 ffffffff     ................
   817a4:	400e0e00 00002000 0000000b 00000001     ...@. ..........
   817b4:	00000000 00000004 ffffffff 400e0e00     ...............@
   817c4:	00001000 0000000b 00000001 00000000     ................
   817d4:	00000004 ffffffff 400e0e00 00000800     ...........@....
   817e4:	0000000b 00000001 00000000 00000004     ................
   817f4:	ffffffff 400e0e00 00000400 0000000b     .......@........
   81804:	00000001 00000000 00000004 ffffffff     ................
   81814:	400e1000 00001000 0000000c 00000001     ...@............
   81824:	00000000 00000004 ffffffff 400e1000     ...............@
   81834:	00002000 0000000c 00000001 00000000     . ..............
   81844:	00000004 ffffffff 400e1000 04000000     ...........@....
   81854:	0000000c 00000004 00000000 00000004     ................
   81864:	ffffffff 400e0e00 00004000 0000000b     .......@.@......
   81874:	00000004 00000000 00000004 ffffffff     ................
   81884:	400e0e00 00008000 0000000b 00000004     ...@............
   81894:	00000000 00000004 ffffffff 400e1400     ...............@
   818a4:	00000001 0000000e 00000004 00000000     ................
   818b4:	00000004 ffffffff 400e1400 00000002     ...........@....
   818c4:	0000000e 00000004 00000000 00000004     ................
   818d4:	ffffffff 400e1400 00000004 0000000e     .......@........
   818e4:	00000004 00000000 00000004 ffffffff     ................
   818f4:	400e1400 00000008 0000000e 00000004     ...@............
   81904:	00000000 00000004 ffffffff 400e1400     ...............@
   81914:	00000040 0000000e 00000004 00000000     @...............
   81924:	00000004 ffffffff 400e1400 00000200     ...........@....
   81934:	0000000e 00000004 00000000 00000004     ................
   81944:	ffffffff 400e0e00 00000080 0000000b     .......@........
   81954:	00000004 00000000 00000004 ffffffff     ................
   81964:	400e1400 00000400 0000000e 00000004     ...@............
   81974:	00000000 00000004 ffffffff 400e1200     ...............@
   81984:	00000002 0000000d 00000004 00000000     ................
   81994:	00000004 ffffffff 400e1200 00000004     ...........@....
   819a4:	0000000d 00000004 00000000 00000004     ................
   819b4:	ffffffff 400e1200 00000008 0000000d     .......@........
   819c4:	00000004 00000000 00000004 ffffffff     ................
   819d4:	400e1200 00000010 0000000d 00000004     ...@............
   819e4:	00000000 00000004 ffffffff 400e1200     ...............@
   819f4:	00000020 0000000d 00000004 00000000      ...............
   81a04:	00000004 ffffffff 400e1200 00000040     ...........@@...
   81a14:	0000000d 00000004 00000000 00000004     ................
   81a24:	ffffffff 400e1200 00000080 0000000d     .......@........
   81a34:	00000004 00000000 00000004 ffffffff     ................
   81a44:	400e1200 00000100 0000000d 00000004     ...@............
   81a54:	00000000 00000004 ffffffff 400e1200     ...............@
   81a64:	00000200 0000000d 00000004 00000000     ................
   81a74:	00000004 ffffffff 400e0e00 00080000     ...........@....
   81a84:	0000000b 00000004 00000000 00000004     ................
   81a94:	ffffffff 400e0e00 00100000 0000000b     .......@........
   81aa4:	00000004 00000000 00000004 ffffffff     ................
   81ab4:	400e1200 00080000 0000000d 00000004     ...@............
   81ac4:	00000000 00000004 ffffffff 400e1200     ...............@
   81ad4:	00040000 0000000d 00000004 00000000     ................
   81ae4:	00000004 ffffffff 400e1200 00020000     ...........@....
   81af4:	0000000d 00000004 00000000 00000004     ................
   81b04:	ffffffff 400e1200 00010000 0000000d     .......@........
   81b14:	00000004 00000000 00000004 ffffffff     ................
   81b24:	400e1200 00008000 0000000d 00000004     ...@............
   81b34:	00000000 00000004 ffffffff 400e1200     ...............@
   81b44:	00004000 0000000d 00000004 00000000     .@..............
   81b54:	00000004 ffffffff 400e1200 00002000     ...........@. ..
   81b64:	0000000d 00000004 00000000 00000004     ................
   81b74:	ffffffff 400e1200 00001000 0000000d     .......@........
   81b84:	00000004 00000000 00000004 ffffffff     ................
   81b94:	400e1000 00200000 0000000c 00000004     ...@.. .........
   81ba4:	00000000 00000004 ffffffff 400e1000     ...............@
   81bb4:	00004000 0000000c 00000004 00000000     .@..............
   81bc4:	00000004 ffffffff 400e0e00 00010000     ...........@....
   81bd4:	0000000b 00000003 00000000 00000002     ................
   81be4:	ffff0700 400e0e00 01000000 0000000b     .......@........
   81bf4:	00000003 00000000 00000002 ffff0601     ................
   81c04:	400e0e00 00800000 0000000b 00000003     ...@............
   81c14:	00000000 00000002 ffff0502 400e0e00     ...............@
   81c24:	00400000 0000000b 00000003 00000000     ..@.............
   81c34:	00000002 ffff0403 400e0e00 00000040     ...........@@...
   81c44:	0000000b 00000003 00000000 00000002     ................
   81c54:	05ff0304 400e0e00 00000010 0000000b     .......@........
   81c64:	00000003 00000000 00000002 ffff0205     ................
   81c74:	400e0e00 00000008 0000000b 00000003     ...@............
   81c84:	00000000 00000002 03ff0106 400e0e00     ...............@
   81c94:	00000004 0000000b 00000003 00000000     ................
   81ca4:	00000002 02ff0007 400e1000 00020000     ...........@....
   81cb4:	0000000c 00000003 00000000 00000002     ................
   81cc4:	ffff0a08 400e1000 00040000 0000000c     .......@........
   81cd4:	00000003 00000000 00000002 ffff0b09     ................
   81ce4:	400e1000 00080000 0000000c 00000003     ...@............
   81cf4:	00000000 00000002 ffff0c0a 400e1000     ...............@
   81d04:	00100000 0000000c 00000003 00000000     ................
   81d14:	00000002 ffff0d0b 400e1000 00008000     ...........@....
   81d24:	0000000c 00000003 00000000 00000002     ................
   81d34:	ffff100c 400e1000 00010000 0000000c     .......@........
   81d44:	00000003 00000000 00000002 ffff110d     ................
   81d54:	400e0e00 00000002 0000000b 00000001     ...@............
   81d64:	00000000 00000004 ffffff0e 400e0e00     ...............@
   81d74:	00000001 0000000b 00000001 00000000     ................
   81d84:	00000004 ffffff0f 400e0e00 00020000     ...........@....
   81d94:	0000000b 00000001 00000000 00000004     ................
   81da4:	ffffffff 400e0e00 00040000 0000000b     .......@........
   81db4:	00000001 00000000 00000004 ffffffff     ................
   81dc4:	400e1200 40000000 0000000d 00000004     ...@...@........
   81dd4:	00000000 00000004 ffffffff 400e0e00     ...............@
   81de4:	00200000 0000000b 00000004 00000000     .. .............
   81df4:	00000004 ffffffff 400e0e00 02000000     ...........@....
   81e04:	0000000b 00000001 00000000 00000004     ................
   81e14:	ffffffff 400e0e00 04000000 0000000b     .......@........
   81e24:	00000001 00000000 00000004 ffffffff     ................
   81e34:	400e0e00 08000000 0000000b 00000001     ...@............
   81e44:	00000000 00000004 ffffffff 400e0e00     ...............@
   81e54:	10000000 0000000b 00000001 00000000     ................
   81e64:	00000004 ffffffff 400e1000 00800000     ...........@....
   81e74:	0000000c 00000002 00000000 00000004     ................
   81e84:	ffffffff 400e0e00 00060000 0000000b     .......@........
   81e94:	00000001 00000000 00000005 ffffffff     ................
   81ea4:	400e1000 00003000 0000000c 00000001     ...@.0..........
   81eb4:	00000000 00000005 ffffffff 400e0e00     ...............@
   81ec4:	00000300 0000000b 00000001 00000000     ................
   81ed4:	00000005 ffffffff 400e0e00 00000c00     ...........@....
   81ee4:	0000000b 00000001 00000000 00000005     ................
   81ef4:	ffffffff 400e0e00 00003000 0000000b     .......@.0......
   81f04:	00000001 00000000 00000005 ffffffff     ................
   81f14:	400e1400 00000030 0000000e 00000002     ...@0...........
   81f24:	00000000 00000005 ffffffff 400e1000     ...............@
   81f34:	00000c00 0000000c 00000001 00000000     ................
   81f44:	00000004 ffffffff 400e1000 00200000     ...........@.. .
   81f54:	0000000c 00000002 00000000 00000004     ................
   81f64:	ffffffff 400e0e00 20000000 0000000b     .......@... ....
   81f74:	00000001 00000000 00000004 ffffffff     ................
   81f84:	400e1000 00008000 0000000c 00000001     ...@............
   81f94:	00000000 00000004 ffffffff 400e1000     ...............@
   81fa4:	00004000 0000000c 00000001 00000000     .@..............
   81fb4:	00000004 ffffffff 400e0e00 00000003     ...........@....
   81fc4:	0000000b 00000001 00000000 00000005     ................
   81fd4:	ffffffff 400e1000 0000c000 0000000c     .......@........
   81fe4:	00000001 00000000 00000005 ffffffff     ................
	...
   8200c:	ffffffff 00000043                       ....C...

00082014 <_global_impure_ptr>:
   82014:	20000008                                ... 

00082018 <_init>:
   82018:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   8201a:	bf00      	nop
   8201c:	bcf8      	pop	{r3, r4, r5, r6, r7}
   8201e:	bc08      	pop	{r3}
   82020:	469e      	mov	lr, r3
   82022:	4770      	bx	lr

00082024 <__init_array_start>:
   82024:	000814f9 	.word	0x000814f9

00082028 <__frame_dummy_init_array_entry>:
   82028:	00080119 00080315 00080471              ........q...

00082034 <_fini>:
   82034:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   82036:	bf00      	nop
   82038:	bcf8      	pop	{r3, r4, r5, r6, r7}
   8203a:	bc08      	pop	{r3}
   8203c:	469e      	mov	lr, r3
   8203e:	4770      	bx	lr

00082040 <__fini_array_start>:
   82040:	000800f5 	.word	0x000800f5
